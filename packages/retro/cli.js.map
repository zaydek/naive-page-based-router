{
  "version": 3,
  "sources": ["../lib/term.ts", "../lib/log.ts", "utils.ts", "cmd_export.ts", "parsePages.ts", "runServerGuards.ts", "cmd_serve.ts", "cli.ts"],
  "sourcesContent": ["export const reset = `\\x1b[0m`\nexport const bold = (...args: unknown[]): string => `\\x1b[0;1m${args.join(\" \")}${reset}`\nexport const gray = (...args: unknown[]): string => `\\x1b[0;2m${args.join(\" \")}${reset}`\nexport const underline = (...args: unknown[]): string => `\\x1b[0;4m${args.join(\" \")}${reset}`\nexport const black = (...args: unknown[]): string => `\\x1b[0;30m${args.join(\" \")}${reset}`\nexport const red = (...args: unknown[]): string => `\\x1b[0;31m${args.join(\" \")}${reset}`\nexport const green = (...args: unknown[]): string => `\\x1b[0;32m${args.join(\" \")}${reset}`\nexport const yellow = (...args: unknown[]): string => `\\x1b[0;33m${args.join(\" \")}${reset}`\nexport const purple = (...args: unknown[]): string => `\\x1b[0;34m${args.join(\" \")}${reset}`\nexport const magenta = (...args: unknown[]): string => `\\x1b[0;35m${args.join(\" \")}${reset}`\nexport const teal = (...args: unknown[]): string => `\\x1b[0;36m${args.join(\" \")}${reset}`\nexport const white = (...args: unknown[]): string => `\\x1b[0;37m${args.join(\" \")}${reset}`\nexport const boldUnderline = (...args: unknown[]): string => `\\x1b[1;4m${args.join(\" \")}${reset}`\nexport const boldBlack = (...args: unknown[]): string => `\\x1b[1;30m${args.join(\" \")}${reset}`\nexport const boldRed = (...args: unknown[]): string => `\\x1b[1;31m${args.join(\" \")}${reset}`\nexport const boldGreen = (...args: unknown[]): string => `\\x1b[1;32m${args.join(\" \")}${reset}`\nexport const boldYellow = (...args: unknown[]): string => `\\x1b[1;33m${args.join(\" \")}${reset}`\nexport const boldPurple = (...args: unknown[]): string => `\\x1b[1;34m${args.join(\" \")}${reset}`\nexport const boldMagenta = (...args: unknown[]): string => `\\x1b[1;35m${args.join(\" \")}${reset}`\nexport const boldTeal = (...args: unknown[]): string => `\\x1b[1;36m${args.join(\" \")}${reset}`\nexport const boldWhite = (...args: unknown[]): string => `\\x1b[1;37m${args.join(\" \")}${reset}`\n", "import * as term from \"./term\"\n\n// prettier-ignore\nfunction formatMessage(msg: string): string {\n\treturn msg.split(\"\\n\").map((each, x) => {\n\t\tif (x === 0) return each\n\t\tif (each === \"\") return each\n\t\treturn \" \".repeat(2) + each.replace(\"\\t\", \"  \")\n\t}).join(\"\\n\")\n}\n\nexport function info(...args: unknown[]): void {\n\tconst message = formatMessage(args.join(\" \"))\n\tconsole.log(`${\" \".repeat(2)}${term.bold(\">\")} ${term.boldGreen(\"ok:\")} ${term.bold(message)}`)\n\tconsole.log()\n}\n\n// TODO: Can we support (...args: unknown[]) here?\nexport function error(error: string | Error): void {\n\tconst message = formatMessage(typeof error === \"object\" ? error.message : error)\n\n\tconst traceEnabled = process.env[\"STACK_TRACE\"] === \"true\"\n\tif (!traceEnabled) {\n\t\tconsole.error(`${\" \".repeat(2)}${term.bold(\">\")} ${term.boldRed(\"error:\")} ${term.bold(message)}`)\n\t\tconsole.error()\n\t} else {\n\t\tconsole.error(`${\" \".repeat(2)}${term.bold(\">\")} ${term.boldRed(\"error:\")} ${term.bold(message)}`)\n\t\tconsole.error()\n\t\tconsole.error({ error })\n\t}\n\tprocess.exit(0)\n}\n", "import readline from \"readline\"\n\nlet willEagerlyTerminate = false\n\n// getWillEagerlyTerminate gets whether the runtime will eagerly terminate.\nexport function getWillEagerlyTerminate(): boolean {\n\treturn willEagerlyTerminate\n}\n\n// setWillEagerlyTerminate sets whether the runtime will eagerly terminate.\nexport function setWillEagerlyTerminate(t: boolean): void {\n\twillEagerlyTerminate = t\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// https://gist.github.com/timneutkens/f2933558b8739bbf09104fb27c5c9664\nexport function clearScreen(): void {\n\tconst emptyScreen = \"\\n\".repeat(process.stdout.rows)\n\tconsole.log(emptyScreen)\n\treadline.cursorTo(process.stdout, 0, 0)\n\treadline.clearScreenDown(process.stdout)\n}\n", "// import * as esbuild from \"esbuild\"\n// import * as fs from \"fs\"\n// import * as p from \"path\"\n// import * as React from \"react\"\n// import * as ReactDOMServer from \"react-dom/server\"\n\nimport * as esbuild from \"esbuild\"\nimport * as fs from \"fs\"\nimport * as log from \"../lib/log\"\nimport * as p from \"path\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\n\nimport parsePages from \"./parsePages\"\nimport runServerGuards from \"./runServerGuards\"\n\n////////////////////////////////////////////////////////////////////////////////\n\nfunction errServerPropsFunction(src: string): string {\n\treturn `${src}: 'typeof serverProps !== \"function\"'; 'serverProps' must be a synchronous or an asynchronous function.\n\nFor example:\n\n// Synchronous:\nfunction serverProps() {\n\treturn { ... }\n}\n\n// Asynchronous:\nasync function serverProps() {\n\tawait ...\n\treturn { ... }\n}`\n}\n\nfunction errServerPropsReturn(src: string): string {\n\treturn `${src}: 'typeof props !== \"object\"'; 'serverProps' must return an object.\n\nFor example:\n\nfunction serverProps() {\n\treturn { ... }\n}`\n}\n\nfunction errServerPathsFunction(src: string): string {\n\treturn `${src}: 'typeof serverPaths !== \"function\"'; 'serverPaths' must be a synchronous or an asynchronous function.\n\nFor example:\n\n// Synchronous:\nfunction serverPaths() {\n\treturn { ... }\n}\n\n// Asynchronous:\nasync function serverPaths() {\n\tawait ...\n\treturn { ... }\n}`\n}\n\n// TODO\nfunction errServerPathsReturn(src: string): string {\n\treturn `${src}: 'typeof props !== \"object\"'; 'serverProps' must return an object.\n\nFor example:\n\nfunction serverProps() {\n\treturn { ... }\n}`\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// // RenderPayload describes a render payload (page metadata).\n// interface RenderPayload {\n// \toutputPath: string\n// \tpath: string\n// \tmodule: types.StaticPageModule | types.DynamicPageModule\n// \tprops?: types.DescriptiveServerProps\n// }\n//\n// // \"/\" -> \"/index.html\"\n// // \"/nested/\" -> \"/nested/index.html\"\n// function pathToHTML(path: string): string {\n// \tif (!path.endsWith(\"/\")) return path + \".html\"\n// \treturn path + \"index.html\"\n// }\n//\n// // exportPage exports a page.\n// async function exportPage(runtime: types.Runtime, render: RenderPayload): Promise<void> {\n// \t// Render head:\n// \tlet head = \"<!-- <Head> -->\"\n// \tif (typeof render.module.Head === \"function\") {\n// \t\tconst markup = ReactDOMServer.renderToStaticMarkup(React.createElement(render.module.Head, render.props))\n// \t\thead = markup.replace(/></g, \">\\n\\t\\t<\").replace(/\\/>/g, \" />\")\n// \t}\n//\n// \t// Render page:\n// \tlet page = `\n// \t\t<noscript>You need to enable JavaScript to run this app.</noscript>\n// \t\t<div id=\"root\"></div>\n// \t\t<script src=\"/app.js\"></script>\n// \t`.trim()\n//\n// \t// prettier-ignore\n// \tif (typeof render.module.default === \"function\") {\n// \t\tconst str = ReactDOMServer.renderToString(React.createElement(render.module.default, render.props))\n// \t\tpage = page.replace(\n// \t\t\t`<div id=\"root\"></div>`,\n// \t\t\t`<div id=\"root\">${str}</div>`,\n// \t\t)\n// \t}\n//\n// \t// prettier-ignore\n// \tconst data = runtime.baseHTML\n// \t\t.replace(\"%head%\", head)\n// \t\t.replace(\"%page%\", page)\n//\n// \t// Export:\n// \tawait fs.promises.mkdir(p.dirname(render.outputPath), { recursive: true })\n// \tawait fs.promises.writeFile(render.outputPath, data)\n// }\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Props describes runtime props.\ntype Props = { [key: string]: unknown }\n\n// DescriptServerProps describes runtime props resolved on the server.\ntype ServerResolvedProps = Props & { path: string }\n\n// PageModule ambiguously describes a page module.\ninterface PageModule {\n\tHead?: (props: ServerResolvedProps) => JSX.Element\n\tdefault?: (props: ServerResolvedProps) => JSX.Element\n}\n\n// StaticPageModule describes a static page module.\ninterface StaticPageModule extends PageModule {\n\tserverProps?(): Promise<ServerResolvedProps>\n}\n\n// DynamicPageModule describes a dynamic page module.\ninterface DynamicPageModule extends PageModule {\n\tserverPaths(): Promise<{ path: string; props: Props }[]>\n}\n\ninterface ServerRouteMeta {\n\tpage: types.PageMeta\n\tserverProps: ServerResolvedProps\n}\n\ninterface ServerResolvedRouter {\n\t[key: string]: ServerRouteMeta\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Based on https://github.com/evanw/esbuild/blob/master/lib/common.ts#L35.\n// prettier-ignore\nfunction testServerPropsReturn(value: unknown): boolean {\n\tconst ok = typeof value === \"object\" &&\n\t\tvalue !== null &&\n\t\t!Array.isArray(value)\n\treturn ok\n}\n\n// TODO\n// prettier-ignore\nfunction testServerPathsReturn(value: unknown): boolean {\n\treturn true\n\n\t// const ok = typeof value === \"object\" &&\n\t// \tvalue !== null &&\n\t// \t!Array.isArray(value)\n\t// return ok\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nasync function resolveStaticRoute(\n\truntime: types.Runtime<types.ExportCommand>,\n\tpage: types.StaticPageMeta,\n\toutfile: string,\n): Promise<ServerRouteMeta> {\n\t// // prettier-ignore\n\t// console.log(`${\" \".repeat(2)}${page.src.slice(runtime.directories.srcPagesDir.length + 1)} -> ${page.dst.slice(runtime.directories.exportDir.length + 1)}`)\n\n\tlet serverProps: ServerResolvedProps = { path: page.path }\n\n\t// NOTE: Use try to suppress: warning: This call to \"require\" will not be\n\t// bundled because the argument is not a string literal (surround with a\n\t// try/catch to silence this warning).\n\tlet mod: StaticPageModule\n\t// prettier-ignore\n\ttry { mod = require(p.join(\"..\", \"..\", outfile)) } catch {}\n\n\tif (mod! !== undefined && \"serverProps\" in mod && typeof mod.serverProps !== \"function\") {\n\t\tlog.error(errServerPropsFunction(page.src))\n\t}\n\n\t// Resolve serverProps:\n\tif (typeof mod!.serverProps === \"function\") {\n\t\ttry {\n\t\t\tconst props = await mod!.serverProps!()\n\t\t\tif (!testServerPropsReturn(props)) {\n\t\t\t\tlog.error(errServerPropsReturn(page.src))\n\t\t\t}\n\t\t\tserverProps = { ...serverProps, ...props }\n\t\t} catch (err) {\n\t\t\tlog.error(`${page.src}.serverProps: ${err.message}`)\n\t\t}\n\t}\n\treturn { page, serverProps }\n}\n\nasync function resolveDynamicPage(\n\t_: types.Runtime<types.ExportCommand>,\n\tpage: types.PageMeta,\n\toutfile: string,\n): Promise<ServerResolvedRouter> {\n\tconst subrouter: ServerResolvedRouter = {}\n\n\t// NOTE: Use try to suppress: warning: This call to \"require\" will not be\n\t// bundled because the argument is not a string literal (surround with a\n\t// try/catch to silence this warning).\n\tlet mod: DynamicPageModule\n\t// prettier-ignore\n\ttry { mod = require(p.join(\"../..\", outfile)) } catch {}\n\n\tif (mod! !== undefined && \"serverPaths\" in mod && typeof mod.serverPaths !== \"function\") {\n\t\tlog.error(errServerPathsFunction(page.src))\n\t}\n\n\t// Resolve serverPaths:\n\tif (typeof mod!.serverPaths === \"function\") {\n\t\ttry {\n\t\t\tconst paths = await mod!.serverPaths!()\n\t\t\tif (!testServerPathsReturn(paths)) {\n\t\t\t\tlog.error(errServerPathsReturn(page.src))\n\t\t\t}\n\t\t\tfor (const path of paths) {\n\t\t\t\tsubrouter[path.path] = {\n\t\t\t\t\tpage,\n\t\t\t\t\tserverProps: {\n\t\t\t\t\t\tpath: path.path,\n\t\t\t\t\t\t...path.props,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlog.error(`${page.src}.serverPaths: ${err.message}`)\n\t\t}\n\t}\n\treturn subrouter\n\n\t//\tif (typeof mod.serverPaths === \"function\") {\n\t//\t\tconst descriptSrvPaths: types.DescriptiveServerPaths = await mod.serverPaths(descriptSrvProps)\n\t//\n\t//\t\t// Generate a component router:\n\t//\t\tconst compRouter: types.ServerRouter = {}\n\t//\t\tfor (const { path, props } of descriptSrvPaths) {\n\t//\t\t\tcompRouter[path] = {\n\t//\t\t\t\troute,\n\t//\t\t\t\tprops: {\n\t//\t\t\t\t\tpath,\n\t//\t\t\t\t\t...props,\n\t//\t\t\t\t},\n\t//\t\t\t}\n\t//\t\t}\n\t//\n\t//\t\tfor (const [path, { props }] of Object.entries(compRouter)) {\n\t//\t\t\t// Merge the component router to the app router:\n\t//\t\t\t//\n\t//\t\t\t// TODO: Warn here for repeat paths.\n\t//\t\t\trouter[path] = { route, props }\n\t//\n\t//\t\t\t// Create a renderPayload for exportPage:\n\t//\t\t\tconst outputPath = p.join(runtime.directoryConfiguration.exportDir, pathToHTML(path))\n\t//\t\t\tconst render: RenderPayload = {\n\t//\t\t\t\toutputPath,\n\t//\t\t\t\tpath,\n\t//\t\t\t\tmodule: mod,\n\t//\t\t\t\tprops,\n\t//\t\t\t}\n\t//\t\t\tawait exportPage(runtime, render)\n\t//\t\t}\n\t//\t\tcontinue\n\t//\t}\n\t//\t// Merge the route to the app router:\n\t//\t//\n\t//\t// TODO: Warn here for repeat paths.\n\t//\tconst path = route.path\n\t//\trouter[path] = { route, props: descriptSrvProps }\n\t//\n\t//\t// Create a renderPayload for exportPage:\n\t//\tconst outputPath = p.join(runtime.directoryConfiguration.exportDir, pathToHTML(path))\n\t//\tconst render: RenderPayload = {\n\t//\t\toutputPath,\n\t//\t\tpath,\n\t//\t\tmodule: mod,\n\t//\t\tprops: descriptSrvProps,\n\t//\t}\n\t//\tawait exportPage(runtime, render)\n}\n\n// resolveServerRouter exports pages and resolves the server router; resolves\n// mod.serverProps and mod.serverPaths.\nasync function resolveServerRouter(runtime: types.Runtime<types.ExportCommand>): Promise<ServerResolvedRouter> {\n\tconst router: ServerResolvedRouter = {}\n\n\t// TODO: Add --concurrent?\n\tconst service = await esbuild.startService()\n\tfor (const page of runtime.pages) {\n\t\t// Generate paths for esbuild:\n\t\tconst entryPoints = [page.src]\n\t\tconst outfile = p.join(runtime.directories.cacheDir, page.src.replace(/\\.(jsx?|tsx?|mdx?)$/, \".esbuild.js\"))\n\n\t\t// Use external: [\"react\", \"react-dom\"] to prevent a React error: You might\n\t\t// have mismatching versions of React and the renderer (such as React DOM).\n\t\tconst result = await service.build({\n\t\t\tbundle: true,\n\t\t\tdefine: {\n\t\t\t\t__DEV__: process.env.__DEV__!,\n\t\t\t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV!),\n\t\t\t},\n\t\t\tentryPoints,\n\t\t\texternal: [\"react\", \"react-dom\"],\n\t\t\tformat: \"cjs\", // Node.js\n\t\t\tinject: [\"packages/retro/react-shim.js\"],\n\t\t\tloader: { \".js\": \"jsx\" },\n\t\t\tlogLevel: \"silent\", // TODO\n\t\t\toutfile,\n\t\t\t// plugins: [...configs.retro.plugins], // TODO\n\t\t})\n\t\t// TODO: Emit warnings here.\n\t\tconsole.log(result)\n\n\t\tif (page.type === \"static\") {\n\t\t\tconst meta = await resolveStaticRoute(runtime, page, outfile)\n\t\t\tif (router[page.path] !== undefined) {\n\t\t\t\tlog.error(`${page.src}: Path '${page.path}' is already being used by ${router[page.path]!.page.src}.`)\n\t\t\t}\n\t\t\trouter[page.path] = meta\n\t\t} else if (page.type === \"dynamic\") {\n\t\t\tconst subrouter = await resolveDynamicPage(runtime, page, outfile)\n\t\t\tfor (const [path, meta] of Object.entries(subrouter)) {\n\t\t\t\tif (router[path] !== undefined) {\n\t\t\t\t\tlog.error(`${page.src}: Path '${path}' is already being used by ${router[path]!.page.src}.`)\n\t\t\t\t}\n\t\t\t\trouter[path] = meta\n\t\t\t}\n\t\t}\n\t}\n\n\tconsole.log(router)\n\treturn router\n}\n\n// // renderAppSource renders the app source code (before esbuild).\n// //\n// // TODO: Write tests (pure function).\n// export async function renderAppSource(runtime: types.Runtime<types.ExportCommand>): Promise<string> {\n// \tconst componentKeys = [...new Set(runtime.routes.map(each => each.component))]\n//\n// \tconst sharedRoutes = runtime.routes\n// \t\t.filter(route => componentKeys.includes(route.component))\n// \t\t.sort((a, b) => a.component.localeCompare(b.component))\n//\n// \tconsole.log(`import React from \"react\"\n// import ReactDOM from \"react-dom\"\n// import { Route, Router } from \"../router\"\n//\n// // Shared components\n// ${sharedRoutes.map(route => `import ${route.component} from \"../${route.src}\"`).join(\"\\n\")}\n//\n// // Server router\n// import router from \"./router.json\"\n// `)\n//\n// \t// \treturn `import React from \"react\"\n// \t// import ReactDOM from \"react-dom\"\n// \t// import { Route, Router } from \"../router\"\n// \t// // Shared components\n// \t// ${sharedComponents.map(component => `import ${component} from \"../${route.inputPath}\"`).join(\"\\n\")}\n// \t// import router from \"./router.json\"\n// \t// export default function App() {\n// \t// \treturn (\n// \t// \t\t<Router>\n// \t// ${\n// \t// \tObject.entries(router)\n// \t// \t\t.map(\n// \t// \t\t\t([path, meta]) => `\n// \t// \t\t\t<Route path=\"${path}\">\n// \t// \t\t\t\t<${meta.route.component} {\n// \t// \t\t\t\t\t...router[\"${path}\"].props\n// \t// \t\t\t\t} />\n// \t// \t\t\t</Route>`,\n// \t// \t\t)\n// \t// \t\t.join(\"\\n\") + \"\\n\"\n// \t// }\n// \t// \t\t</Router>\n// \t// \t)\n// \t// }\n// \t// ${\n// \t// \tJSON.parse(process.env.STRICT_MODE || \"true\")\n// \t// \t\t? `ReactDOM.${JSON.parse(process.env.RENDER || \"false\") ? \"render\" : \"hydrate\"}(\n// \t// \t<React.StrictMode>\n// \t// \t\t<App />\n// \t// \t</React.StrictMode>,\n// \t// \tdocument.getElementById(\"root\"),\n// \t// )`\n// \t// \t\t: `ReactDOM.${JSON.parse(process.env.RENDER || \"false\") ? \"render\" : \"hydrate\"}(\n// \t// \t<App />,\n// \t// \tdocument.getElementById(\"root\"),\n// \t// )`\n// \t// }\n// \t// `\n//\n// \treturn \"TODO\"\n// }\n\nconst cmd_export: types.cmd_export = async runtime => {\n\tawait runServerGuards(runtime.directories)\n\tconst data = await fs.promises.readFile(p.join(runtime.directories.publicDir, \"index.html\"))\n\truntime.document = data.toString()\n\truntime.pages = await parsePages(runtime.directories)\n\n\tresolveServerRouter(runtime)\n\t// const router =\n\n\t// const appSource =\n\t// await renderAppSource(runtime)\n\t// console.log(appSource)\n\n\t// const appSourcePath = p.join(runtime.directoryConfiguration.cacheDir, \"app.js\")\n\t// await fs.promises.writeFile(appSourcePath, appSource)\n\t//\n\t// // Generate paths for esbuild:\n\t// const entryPoints = [appSourcePath]\n\t// const outfile = entryPoints[0]!.replace(\n\t// \tnew RegExp(\"^\" + runtime.directoryConfiguration.cacheDir.replace(\"/\", \"\\\\/\")),\n\t// \truntime.directoryConfiguration.exportDir,\n\t// )\n\t//\n\t// await esbuild.build({\n\t// \tbundle: true,\n\t// \tdefine: {\n\t// \t\t__DEV__: process.env.__DEV__!,\n\t// \t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV),\n\t// \t},\n\t// \tentryPoints,\n\t// \tformat: \"iife\", // DOM\n\t// \tinject: [\"scripts/react-shim.js\"],\n\t// \tloader: { \".js\": \"jsx\" },\n\t// \tlogLevel: \"silent\", // TODO\n\t// \tminify: true,\n\t// \toutfile,\n\t// \t// TODO: We should probably only need to resolve plugins once.\n\t// \t// plugins: [...configs.retro.plugins],\n\t// })\n\t// // TODO: Handle warnings, error, and hints.\n}\n\nexport default cmd_export\n\n// ;(async () => {\n// \ttry {\n// \t\tawait run(require(\"../__cache__/runtime.json\"))\n// \t} catch (error) {\n// \t\tconsole.error(error.stack)\n// \t}\n// })()\n", "import * as fs from \"fs\"\nimport * as log from \"../lib/log\"\nimport * as p from \"path\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\n\n// prettier-ignore\ninterface ParsedPath {\n\tsrc:      string // e.g. \"path/to/basename.ext\"\n\tbasename: string // e.g. \"basename.ext\"\n\tname:     string // e.g. \"basename\"\n\text:      string // e.g. \".ext\"\n}\n\n// prettier-ignore\nconst supported: { [key: string]: boolean } = {\n\t\".js\":  true,\n\t\".jsx\": true,\n\t\".ts\":  true,\n\t\".tsx\": true,\n\t\".md\":  true,\n\t\".mdx\": true,\n}\n\n// parsePath parses path metadata so that syntax functions don\u2019t need to\n// re-parse path metadata.\nfunction parsePath(path: string): ParsedPath {\n\tconst basename = p.basename(path)\n\tconst ext = p.extname(path)\n\tconst name = basename.slice(0, -ext.length)\n\treturn { src: path, basename, name, ext }\n}\n\n// src/pages/index.js -> __export__/index.html\n//\n// TODO: Write tests.\nfunction dst(directories: types.DirConfiguration, path: ParsedPath): string {\n\tconst syntax = p.join(directories.exportDir, path.src.slice(directories.srcPagesDir.length))\n\treturn syntax.slice(0, -path.ext.length) + \".html\"\n}\n\n// \"src/pages/component.js\"          -> \"PageComponent\"\n// \"src/pages/nested/component.js\"   -> \"PageNestedComponent\"\n// \"src/pages/[component].js\"        -> \"DynamicPageComponent\"\n// \"src/pages/nested/[component].js\" -> \"DynamicPageNestedComponent\"\n//\n// TODO: Write tests.\nfunction toComponentSyntax(\n\tdirectories: types.DirConfiguration,\n\tparsed: ParsedPath,\n\t{ dynamic }: { dynamic: boolean },\n): string {\n\tlet path = toPathSyntax(directories, parsed)\n\tif (dynamic) {\n\t\t// Remove \"[\" and \"]\":\n\t\tpath = path.replace(dynamicRegex, \"$1$3\")\n\t}\n\tlet syntax = \"\"\n\tfor (const part of path.split(p.sep)) {\n\t\tif (!part.length) continue\n\t\tsyntax += part[0]!.toUpperCase() + part.slice(1)\n\t}\n\tsyntax = syntax || \"Index\"\n\treturn (dynamic ? \"DynamicPage\" : \"Page\") + syntax[0]!.toUpperCase() + syntax.slice(1)\n}\n\n// \"src/pages/index.js\"       -> \"/\"\n// \"src/pages/hello-world.js\" -> \"/hello-world\"\n//\n// TODO: Write tests.\nfunction toPathSyntax(directories: types.DirConfiguration, parsed: ParsedPath): string {\n\tconst syntax = parsed.src.slice(directories.srcPagesDir.length, -parsed.ext.length)\n\tif (syntax.endsWith(\"/index\")) {\n\t\treturn syntax.slice(0, -\"index\".length)\n\t}\n\treturn syntax\n}\n\n// TODO: Write tests.\nfunction createStaticPageMeta(directories: types.DirConfiguration, parsed: ParsedPath): types.StaticPageMeta {\n\tconst component: types.StaticPageMeta = {\n\t\ttype: \"static\",\n\t\tsrc: parsed.src,\n\t\tdst: dst(directories, parsed),\n\t\tpath: toPathSyntax(directories, parsed),\n\t\tcomponent: toComponentSyntax(directories, parsed, { dynamic: false }),\n\t}\n\treturn component\n}\n\n// TODO: Write tests.\nfunction createDynamicPageMeta(directories: types.DirConfiguration, parsed: ParsedPath): types.DynamicPageMeta {\n\tconst component: types.DynamicPageMeta = {\n\t\ttype: \"dynamic\",\n\t\tsrc: parsed.src,\n\t\tcomponent: toComponentSyntax(directories, parsed, { dynamic: true }),\n\t}\n\treturn component\n}\n\n// Matches:\n//\n// - $1 -> \"/\"\n// - $2 -> \"[\"\n// - $3 -> ...\n// - $4 -> \"]\"\n//\n// TODO: Write tests.\nconst dynamicRegex = /(\\/)(\\[)([a-zA-Z0-9\\-\\.\\_\\~\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]+)(\\])/\n\nfunction parsePage(directories: types.DirConfiguration, parsed: ParsedPath): types.PageMeta {\n\tconst path = toPathSyntax(directories, parsed)\n\tif (dynamicRegex.test(path)) {\n\t\treturn createDynamicPageMeta(directories, parsed)\n\t}\n\treturn createStaticPageMeta(directories, parsed)\n}\n\nasync function readdirAll(src: string): Promise<ParsedPath[]> {\n\tconst arr: ParsedPath[] = []\n\tasync function recurse(src: string): Promise<void> {\n\t\tconst ls = await fs.promises.readdir(src)\n\t\tfor (const each of ls) {\n\t\t\tconst path = p.join(src, each)\n\t\t\tif ((await fs.promises.stat(path)).isDirectory()) {\n\t\t\t\tarr.push(parsePath(path))\n\t\t\t\tawait recurse(path)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tarr.push(parsePath(path))\n\t\t}\n\t}\n\tawait recurse(src)\n\treturn arr\n}\n\n// testURICharacter tests whether a character matches URI reserved or unreserved\n// characters based on RFC 3986.\nfunction testURICharacter(char: string): boolean {\n\t// prettier-ignore\n\tif ((char >= \"a\" && char <= \"z\") || // ALPHA LOWER\n\t\t\t(char >= \"A\" && char <= \"Z\") || // ALPHA LOWER\n\t\t\t(char >= \"0\" && char <= \"9\")) { // DIGIT\n\t\treturn true\n\t}\n\t// https://tools.ietf.org/html/rfc3986#section-2.3\n\tswitch (char) {\n\t\tcase \"-\":\n\t\tcase \".\":\n\t\tcase \"_\":\n\t\tcase \"~\":\n\t\t\treturn true\n\t}\n\t// https://tools.ietf.org/html/rfc3986#section-2.2\n\tswitch (char) {\n\t\tcase \":\":\n\t\tcase \"/\":\n\t\tcase \"?\":\n\t\tcase \"#\":\n\t\tcase \"[\":\n\t\tcase \"]\":\n\t\tcase \"@\":\n\t\tcase \"!\":\n\t\tcase \"$\":\n\t\tcase \"&\":\n\t\tcase \"'\":\n\t\tcase \"(\":\n\t\tcase \")\":\n\t\tcase \"*\":\n\t\tcase \"+\":\n\t\tcase \",\":\n\t\tcase \";\":\n\t\tcase \"=\":\n\t\t\treturn true\n\t}\n\treturn false\n}\n\nexport default async function parsePages(directories: types.DirConfiguration): Promise<types.PageMeta[]> {\n\tconst arr = await readdirAll(directories.srcPagesDir)\n\n\t// Step over:\n\t//\n\t// - \"_component\"\n\t// - \"$component\"\n\t// - \"component_\"\n\t// - \"component$\"\n\t//\n\t// TODO: Add support for \"layout\" here?\n\tconst arr2 = arr.filter(path => {\n\t\tif (path.name.startsWith(\"_\") || path.name.startsWith(\"$\")) {\n\t\t\treturn false\n\t\t} else if (path.name.endsWith(\"_\") || path.name.endsWith(\"$\")) {\n\t\t\treturn false\n\t\t}\n\t\treturn supported[path.ext] === true\n\t})\n\n\tconst badSrcs: string[] = []\n\tfor (const { src } of arr2) {\n\t\tfor (let x = 0; x < src.length; x++) {\n\t\t\tif (!testURICharacter(src[x]!)) {\n\t\t\t\tbadSrcs.push(src)\n\t\t\t}\n\t\t}\n\t}\n\n\tif (badSrcs.length > 0) {\n\t\tlog.error(`These pages use non-URI characters:\n\n${badSrcs.map(each => \"- \" + each).join(\"\\n\")}\n\nURI characters are described by RFC 3986:\n\n2.2. Unreserved Characters\n\n\tALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\n2.3. Reserved Characters\n\n\tgen-delims = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" /\n\tsub-delims = \"@\" / \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n\t           / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\n${term.boldUnderline(\"https://tools.ietf.org/html/rfc3986\")}`)\n\t}\n\n\tconst pages: types.PageMeta[] = []\n\tfor (const parsed of arr2) {\n\t\tpages.push(parsePage(directories, parsed))\n\t}\n\treturn pages\n}\n", "import * as fs from \"fs\"\nimport * as log from \"../lib/log\"\nimport * as p from \"path\"\nimport * as types from \"./types\"\n\n// runServerGuards tests for the presence of directories and public/index.html.\nexport default async function runServerGuards(dir: types.DirConfiguration): Promise<void> {\n\tconst dirs = Object.entries(dir).map(([_, v]) => v)\n\n\t// Guards directories:\n\tfor (const dir_ of dirs) {\n\t\ttry {\n\t\t\tawait fs.promises.stat(dir_)\n\t\t} catch (_) {\n\t\t\tfs.promises.mkdir(dir_, { recursive: true })\n\t\t}\n\t}\n\n\t// Guards public/index.html:\n\tconst path = p.join(dir.publicDir, \"index.html\")\n\ttry {\n\t\tconst data = await fs.promises.readFile(path)\n\t\tconst text = data.toString()\n\t\tif (!text.includes(\"%head\")) {\n\t\t\tlog.error(`${path}: Add '%head%' somewhere to '<head>'.\n\nFor example:\n\n...\n<head>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\t%head%\n</head>\n...`)\n\t\t} else if (!text.includes(\"%app\")) {\n\t\t\tlog.error(`${path}: Add '%app%' somewhere to '<body>'.\n\nFor example:\n\n...\n<body>\n\t<noscript>You need to enable JavaScript to run this app.</noscript>\n\t<div id=\"app\"></div>\n\t%app%\n</body>\n...`)\n\t\t}\n\t} catch (_) {\n\t\tawait fs.promises.writeFile(\n\t\t\tpath,\n\t\t\t`<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\t\t%head%\n\t</head>\n\t<body>\n\t\t<noscript>You need to enable JavaScript to run this app.</noscript>\n\t\t<div id=\"app\"></div>\n\t\t%app%\n\t</body>\n</html>\n`,\n\t\t)\n\t}\n}\n", "import * as esbuild from \"esbuild\"\nimport * as http from \"http\"\nimport * as log from \"../lib/log\"\nimport * as p from \"path\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\n// spaify converts a URL for SPA-mode.\nfunction spaify(_: string): string {\n\treturn \"/\"\n}\n\n// ssgify converts a URL for SSG-mode.\nfunction ssgify(url: string): string {\n\tif (url.endsWith(\"/\")) return url + \"index.html\"\n\tif (p.extname(url) === \"\") return url + \".html\"\n\treturn url\n}\n\n// This implementation is roughly based on:\n//\n// - https://esbuild.github.io/api/#customizing-server-behavior\n// - https://github.com/evanw/esbuild/issues/858#issuecomment-782814216\n//\nconst serve: types.cmd_serve = async runtime => {\n\tsetTimeout(() => {\n\t\tif (utils.getWillEagerlyTerminate()) return\n\t\tutils.clearScreen()\n\t\tconsole.log()\n\t\tlog.info(`http://localhost:${runtime.command.port}`)\n\t}, 10)\n\n\t// prettier-ignore\n\tconst result = await esbuild.serve({\n\t\tservedir: runtime.directories.exportDir,\n\t\tonRequest: (args: esbuild.ServeOnRequestArgs) => {\n\t\t\tlet color: Function\n\t\t\tif (args.status >= 200 && args.status < 300) {\n\t\t\t\tcolor = term.green\n\t\t\t} else {\n\t\t\t\tcolor = term.red\n\t\t\t}\n\t\t\tlet descriptMs = \"\"\n\t\t\tif (args.status >= 200 && args.status < 300) {\n\t\t\t\tdescriptMs += ` (${args.timeInMS}ms)`\n\t\t\t\tif (args.timeInMS === 0) {\n\t\t\t\t\tdescriptMs = descriptMs.slice(0, -1) + \" - cached)\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(`${\" \".repeat(2)}${color(`[${args.status}]`)} ${args.method} ${args.path}${descriptMs}`)\n\t\t},\n\t}, {})\n\n\tlet transformURL = ssgify\n\tif (runtime.command.mode === \"spa\") {\n\t\ttransformURL = spaify\n\t}\n\n\t// The proxy server.\n\tconst proxySrv = http.createServer((req, res) => {\n\t\t// The proxy request.\n\t\tconst proxyReq = http.request({ ...req, path: transformURL(req.url!), port: result.port }, proxyRes => {\n\t\t\t// The proxy response.\n\t\t\tif (proxyRes.statusCode === 404) {\n\t\t\t\tres.writeHead(200, { \"Content-Type\": \"text/plain\" })\n\t\t\t\tres.end(\"404 page not found\")\n\t\t\t} else {\n\t\t\t\tres.writeHead(proxyRes.statusCode!, proxyRes.headers)\n\t\t\t\tproxyRes.pipe(res, { end: true })\n\t\t\t}\n\t\t})\n\t\treq.pipe(proxyReq, { end: true })\n\t})\n\tproxySrv.listen(runtime.command.port)\n}\n\nexport default serve\n", "import * as log from \"../lib/log\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\nimport cmd_export from \"./cmd_export\"\nimport cmd_serve from \"./cmd_serve\"\n\nconst cmds = `\nretro dev     Start the dev server\nretro export  Export the production-ready build (SSG)\nretro serve   Serve the production-ready build\n`.trim()\n\n// NOTE: Use spaces here.\nconst usage = `${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n  ${term.bold(\"Usage:\")}\n\n    retro dev     Start the dev server\n    retro export  Export the production-ready build (SSG)\n    retro serve   Serve the production-ready build\n\n  ${term.bold(\"retro dev\")}\n\n    Start the dev server\n\n      --cached=...     Use cached resources (default false)\n      --sourcemap=...  Add source maps (default true)\n      --port=...       Port number (default 8000)\n\n  ${term.bold(\"retro export\")}\n\n    Export the production-ready build (SSG)\n\n      --cached=...     Use cached resources (default false)\n      --sourcemap=...  Add source maps (default true)\n\n  ${term.bold(\"retro serve\")}\n\n    Serve the production-ready build\n\n      --mode=...       Serve mode 'spa' or 'ssg' (default 'ssg')\n      --port=...       Port number (default 8000)\n\n  ${term.bold(\"Repository:\")}\n\n    ${term.underline(\"https://github.com/zaydek/retro\")}\n`\n\n// parseDevCommandFlags parses 'retro dev [flags]'.\n//\n// TODO: Write tests.\nfunction parseDevCommandFlags(...args: string[]): types.DevCommand {\n\tconst cmd: types.DevCommand = {\n\t\ttype: \"dev\",\n\t\tcached: false,\n\t\tsourcemap: true,\n\t\tport: 8000,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\tif (arg === \"--cached\") {\n\t\t\t\tcmd.cached = true\n\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\tcmd.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--cached\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\tcmd.sourcemap = true\n\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\tcmd.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--sourcemap\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--port\")) {\n\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\tcmd.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--port\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\tif (cmd.port < 1e3 || cmd.port >= 1e4) {\n\t\tlog.error(\"'--port' must be between 1000-9999.\")\n\t}\n\treturn cmd\n}\n\n// parseExportCommandFlags parses 'retro export [flags]'.\n//\n// TODO: Write tests.\nfunction parseExportCommandFlags(...args: string[]): types.ExportCommand {\n\tconst cmd: types.ExportCommand = {\n\t\ttype: \"export\",\n\t\tcached: false,\n\t\tsourcemap: true,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\tif (arg === \"--cached\") {\n\t\t\t\tcmd.cached = true\n\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\tcmd.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--cached\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\tcmd.sourcemap = true\n\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\tcmd.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--sourcemap\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\treturn cmd\n}\n\n// parseServeCommandFlags parses 'retro serve [flags]'.\n//\n// TODO: Write tests.\nfunction parseServeCommandFlags(...args: string[]): types.ServeCommand {\n\tconst cmd: types.ServeCommand = {\n\t\ttype: \"serve\",\n\t\tmode: \"ssg\",\n\t\tport: 8000,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--mode\")) {\n\t\t\tif (arg === \"--mode=spa\") {\n\t\t\t\tcmd.mode = \"spa\"\n\t\t\t} else if (arg === \"--mode=ssg\") {\n\t\t\t\tcmd.mode = \"ssg\"\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--mode\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--port\")) {\n\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\tcmd.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--port\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\tif (cmd.port < 1e3 || cmd.port >= 1e4) {\n\t\tlog.error(\"'--port' must be between 1000-9999.\")\n\t}\n\treturn cmd\n}\n\nasync function run(): Promise<void> {\n\tconsole.log(`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}`)\n\tconsole.log()\n\n\tconst args = process.argv0 === \"node\" ? process.argv.slice(1) : process.argv\n\n\t// Cover [\"retro\"] case:\n\tif (args.length === 1) {\n\t\tconsole.log(usage)\n\t\tprocess.exit(0)\n\t}\n\n\tlet command: types.Command\n\tconst arg = args[1]\n\tif (arg === \"version\" || arg === \"--version\" || arg === \"--v\") {\n\t\tconsole.log(process.env[\"RETRO_VERSION\"] || \"TODO\")\n\t\tprocess.exit(0)\n\t} else if (arg === \"usage\" || arg === \"--usage\" || arg === \"help\" || arg === \"--help\") {\n\t\tconsole.log(usage)\n\t\tprocess.exit(0)\n\t} else if (arg === \"dev\") {\n\t\tprocess.env[\"__DEV__\"] = \"true\"\n\t\tprocess.env[\"NODE_ENV\"] = \"development\"\n\t\tcommand = parseDevCommandFlags(...args.slice(2))\n\t} else if (arg === \"export\") {\n\t\tprocess.env[\"__DEV__\"] = \"false\"\n\t\tprocess.env[\"NODE_ENV\"] = \"production\"\n\t\tcommand = parseExportCommandFlags(...args.slice(2))\n\t} else if (arg === \"serve\") {\n\t\tprocess.env[\"__DEV__\"] = \"false\"\n\t\tprocess.env[\"NODE_ENV\"] = \"production\"\n\t\tcommand = parseServeCommandFlags(...args.slice(2))\n\t} else {\n\t\tlog.error(`No such command '${arg}'. Use one of these commands:\n\n${cmds}\n\nOr 'retro usage' for usage.`)\n\t}\n\n\t// prettier-ignore\n\tconst runtime: types.Runtime = {\n\t\tcommand: command!,\n\t\tdirectories: {\n\t\t\tpublicDir:   process.env.PUBLIC_DIR || \"public\",\n\t\t\tsrcPagesDir: process.env.PAGES_DIR  || \"src/pages\",\n\t\t\tcacheDir:    process.env.CACHE_DIR  || \"__cache__\",\n\t\t\texportDir:   process.env.EXPORT_DIR || \"__export__\",\n\t\t},\n\t\tdocument: \"\", // Defer to dev and export\n\t\tpages: [],    // Defer to dev and export\n\t}\n\n\tif (runtime.command.type === \"dev\") {\n\t\t// await cmd_dev(runtime as types.Runtime<types.DevCommand>)\n\t} else if (runtime.command.type === \"export\") {\n\t\tawait cmd_export(runtime as types.Runtime<types.ExportCommand>)\n\t} else if (runtime.command.type === \"serve\") {\n\t\tawait cmd_serve(runtime as types.Runtime<types.ServeCommand>)\n\t}\n}\n\nprocess.on(\"uncaughtException\", err => {\n\tutils.setWillEagerlyTerminate(true)\n\tprocess.env[\"STACK_TRACE\"] = \"true\"\n\terr.message = `UncaughtException: ${err.message}`\n\tlog.error(err)\n})\n\nrun()\n"],
  "mappings": "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",
  "names": []
}
