{
  "version": 3,
  "sources": ["../lib/term.ts", "../lib/log.ts", "utils/formatEsbuild.ts", "utils/logTypes.ts", "utils/parsePages.ts", "errs.ts", "utils/preflight.ts", "utils/prettyJSON.ts", "utils/validators.ts", "utils/watcher.ts", "cmd_dev.ts", "cmd_export.ts", "resolvers.ts", "cmd_serve.ts", "cli.ts"],
  "sourcesContent": ["// BuilderFunction describes the builder pattern where a function or a method\n// (recursively) can be called.\n//\n// For example:\n//\n// - function(...)\n// - function.method(...)\n// - function.method.method(...)\n//\nexport interface Builder {\n\t(...args: unknown[]): string\n\tnormal: Builder\n\tbold: Builder\n\tdim: Builder\n\tunderline: Builder\n\tblack: Builder\n\tred: Builder\n\tgreen: Builder\n\tyellow: Builder\n\tblue: Builder\n\tmagenta: Builder\n\tcyan: Builder\n\twhite: Builder\n\tbgBlack: Builder\n\tbgRed: Builder\n\tbgGreen: Builder\n\tbgYellow: Builder\n\tbgBlue: Builder\n\tbgMagenta: Builder\n\tbgCyan: Builder\n\tbgWhite: Builder\n}\n\nconst options = [\n\t{ name: \"normal\", code: \"\\x1b[0m\" },\n\t{ name: \"bold\", code: \"\\x1b[1m\" },\n\t{ name: \"dim\", code: \"\\x1b[2m\" },\n\t{ name: \"underline\", code: \"\\x1b[4m\" },\n\t{ name: \"black\", code: \"\\x1b[30m\" },\n\t{ name: \"red\", code: \"\\x1b[31m\" },\n\t{ name: \"green\", code: \"\\x1b[32m\" },\n\t{ name: \"yellow\", code: \"\\x1b[33m\" },\n\t{ name: \"blue\", code: \"\\x1b[34m\" },\n\t{ name: \"magenta\", code: \"\\x1b[35m\" },\n\t{ name: \"cyan\", code: \"\\x1b[36m\" },\n\t{ name: \"white\", code: \"\\x1b[37m\" },\n\t{ name: \"bgBlack\", code: \"\\x1b[40m\" },\n\t{ name: \"bgRed\", code: \"\\x1b[41m\" },\n\t{ name: \"bgGreen\", code: \"\\x1b[42m\" },\n\t{ name: \"bgYellow\", code: \"\\x1b[43m\" },\n\t{ name: \"bgBlue\", code: \"\\x1b[44m\" },\n\t{ name: \"bgMagenta\", code: \"\\x1b[45m\" },\n\t{ name: \"bgCyan\", code: \"\\x1b[46m\" },\n\t{ name: \"bgWhite\", code: \"\\x1b[47m\" },\n]\n\n// function clean(str: string): string {\n// \tlet out = \"\"\n//\n// \tlet x = 0\n// \twhile (x < str.length) {\n// \t\tlet codes: string[] = []\n// \t\tlet x2 = x\n//\n// \t\t// On \"\\x1b\":\n// \t\twhile (str[x2] === \"\\x1b\") {\n// \t\t\tx2++\n//\n// \t\t\t// Step over \"[\":\n// \t\t\tif (x2 >= str.length || str[x2] !== \"[\") {\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t\tx2++\n// \t\t\t// Step over /\\d+/:\n// \t\t\tconst start = x2\n// \t\t\twhile (x2 < str.length) {\n// \t\t\t\tif (str[x2]! < \"0\" || str[x2]! > \"9\") {\n// \t\t\t\t\tbreak\n// \t\t\t\t}\n// \t\t\t\tx2++\n// \t\t\t}\n// \t\t\t// Guard /\\d+/:\n// \t\t\tconst end = x2\n// \t\t\tif (start === end) {\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t\t// Step over \"m\":\n// \t\t\tif (x2 >= str.length || str[x2] !== \"m\") {\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t\tx2++\n// \t\t\tcodes.push(str.slice(start, end))\n// \t\t}\n//\n// \t\t// On one or more code matches:\n// \t\tif (codes.length > 0) {\n// \t\t\tout += `\\x1b[${codes.join(\";\")}m`\n// \t\t\tx = x2\n// \t\t\tcontinue\n// \t\t}\n//\n// \t\t// Shortcut:\n// \t\tif (x2 > x) {\n// \t\t\tout += str.slice(x, x2)\n// \t\t\tx = x2\n// \t\t\tcontinue\n// \t\t}\n// \t\tout += str[x]\n// \t\tx++\n// \t}\n// \treturn out\n// }\n\nfunction build(...codes: string[]): Builder {\n\tconst set = new Set(codes)\n\n\tfunction format(...args: unknown[]): string {\n\t\tconst coded = [...set].join(\"\")\n\t\t// return clean(coded + args.join(\" \").replaceAll(\"\\x1b[0m\", \"\\x1b[0m\" + coded) + \"\\x1b[0m\")\n\t\treturn coded + args.join(\" \").replaceAll(\"\\x1b[0m\", \"\\x1b[0m\" + coded) + \"\\x1b[0m\"\n\t}\n\n\tfor (const { name, code } of options) {\n\t\tObject.defineProperty(format, name, {\n\t\t\tenumerable: true,\n\t\t\tget() {\n\t\t\t\treturn build(...[...codes, code])\n\t\t\t},\n\t\t})\n\t}\n\n\t// NOTE: Use 'as builder' because there\u2019s no initializer syntax for functions\n\t// with methods.\n\treturn format as Builder\n}\n\nexport const noop = (...args: unknown[]): string => args.join(\" \")\nexport const normal = build(\"\\x1b[0m\")\nexport const bold = build(\"\\x1b[1m\")\nexport const dim = build(\"\\x1b[2m\")\nexport const underline = build(\"\\x1b[4m\")\nexport const black = build(\"\\x1b[30m\")\nexport const red = build(\"\\x1b[31m\")\nexport const green = build(\"\\x1b[32m\")\nexport const yellow = build(\"\\x1b[33m\")\nexport const blue = build(\"\\x1b[34m\")\nexport const magenta = build(\"\\x1b[35m\")\nexport const cyan = build(\"\\x1b[36m\")\nexport const white = build(\"\\x1b[37m\")\nexport const bgBlack = build(\"\\x1b[40m\")\nexport const bgRed = build(\"\\x1b[41m\")\nexport const bgGreen = build(\"\\x1b[42m\")\nexport const bgYellow = build(\"\\x1b[43m\")\nexport const bgBlue = build(\"\\x1b[44m\")\nexport const bgMagenta = build(\"\\x1b[45m\")\nexport const bgCyan = build(\"\\x1b[46m\")\nexport const bgWhite = build(\"\\x1b[47m\")\n", "import * as term from \"../lib/term\"\n\n// format converts tabs to spaces and adds two spaces to the start.\nfunction format(...args: unknown[]): string {\n\tif (args.length === 1 && args[0] instanceof Error) {\n\t\treturn format(args[0].message)\n\t}\n\n\treturn args\n\t\t.join(\" \")\n\t\t.split(\"\\n\")\n\t\t.map((each, x) => {\n\t\t\t// if (x === 0) return term.bold(each)\n\t\t\tif (x === 0) return each\n\t\t\tif (each === \"\") return each\n\t\t\treturn \"\\x20\" + each.replace(\"\\t\", \"  \")\n\t\t})\n\t\t.join(\"\\n\")\n}\n\n// \"> ok: ...\"\nexport function ok(...args: unknown[]): void {\n\tconst message = format(...args)\n\tconsole.log(`\\x20${term.bold(\">\")} ${term.bold(message)}`)\n\tconsole.log()\n}\n\n// \"> warning: ...\"\nexport function warning(...args: unknown[]): void {\n\tconst message = format(...args)\n\tconsole.warn(`\\x20${term.bold(\">\")} ${term.bold.yellow(\"warning:\")} ${term.bold(message)}`)\n\tconsole.warn()\n}\n\n// \"> error: ...\"\nexport function error(...args: unknown[]): void {\n\tconst message = format(...args)\n\tconst traceEnabled = process.env[\"STACK_TRACE\"] === \"true\"\n\tif (!traceEnabled) {\n\t\tconsole.error(`\\x20${term.bold(\">\")} ${term.bold.red(\"error:\")} ${term.bold(message)}`)\n\t\tconsole.error()\n\t} else {\n\t\tconsole.error(`\\x20${term.bold(\">\")} ${term.bold.red(\"error:\")} ${term.bold(message)}`)\n\t\tconsole.error()\n\t}\n\tprocess.exit(0)\n}\n", "import * as esbuild from \"esbuild\"\nimport * as term from \"../../lib/term\"\n\n// loc.file:loc.line:loc.column: msg.text\n//\n// loc.line | loc.lineText\n//            ~~~~~~~~~~~~\n//\nexport function formatEsbuildMessage(msg: esbuild.Message, color: (...args: unknown[]) => void): string {\n\tconst loc = msg.location!\n\treturn `${loc.file}:${loc.line}:${loc.column}: ${msg.text}\n\n\t${loc.line} ${term.dim(\"\u2502\")} ${loc.lineText}\n\t${\" \".repeat(String(loc.line).length)} ${term.dim(\"\u2502\")} ${\" \".repeat(loc.column)}${color(\"~\".repeat(loc.length))}`\n\t// ${\" \".repeat(String(loc.line).length)} ${term.dim(\"\u2502\")} ${\" \".repeat(loc.column)}${color(\"^\")}`\n}\n", "import * as esbuild from \"esbuild\"\nimport * as p from \"path\"\nimport * as term from \"../../lib/term\"\nimport * as types from \"../types\"\n\ninterface TimeInfo {\n\thh: string // e.g. \"03\"\n\tmm: string // e.g. \"04\"\n\tss: string // e.g. \"05\"\n\tam: string // e.g. \"AM\"\n\tms: string // e.g. \"000\"\n}\n\nconst TERM_WIDTH = 35\n\nfunction getTimeInfo(): TimeInfo {\n\tconst date = new Date()\n\tconst hh = String(date.getHours() % 12 || 12).padStart(2, \"0\")\n\tconst mm = String(date.getMinutes()).padStart(2, \"0\")\n\tconst ss = String(date.getSeconds()).padStart(2, \"0\")\n\tconst am = date.getHours() < 12 ? \"AM\" : \"PM\"\n\tconst ms = String(date.getMilliseconds()).slice(0, 3).padStart(3, \"0\")\n\treturn { hh, mm, ss, am, ms }\n}\n\nfunction formatMs(ms: number): string {\n\tswitch (true) {\n\t\tcase ms < 250:\n\t\t\treturn `${ms}ms` // `${String(ms).padStart(3, \"0\")}ms`\n\t\tdefault:\n\t\t\treturn `${(ms / 1e3).toFixed(2)}s`\n\t}\n}\n\nlet once = false\n\nexport function serveEvent(args: esbuild.ServeOnRequestArgs): void {\n\ttype Logger = (...args: unknown[]) => void\n\n\tconst { hh, mm, ss, am, ms } = getTimeInfo()\n\n\tconst dur = formatMs(args.timeInMS)\n\n\tlet color = term.normal\n\tif (args.status < 200 || args.status >= 300) {\n\t\tcolor = term.red\n\t}\n\n\tlet dimColor = term.dim\n\tif (args.status < 200 || args.status >= 300) {\n\t\tdimColor = term.dim.red\n\t}\n\n\tlet logger: Logger = (...args) => console.log(...args)\n\tif (args.status < 200 || args.status >= 300) {\n\t\tlogger = (...args) => console.error(...args) // eslint-disable-line\n\t}\n\n\tconst path = args.path\n\tconst path_ext = p.extname(path)\n\tconst path_name = path.slice(1, -path_ext.length)\n\n\tconst sep = \"-\".repeat(Math.max(0, TERM_WIDTH - `/${path_name}${path_ext}\\x20`.length))\n\n\tif (!once) {\n\t\tlogger()\n\t\tonce = true\n\t}\n\tlogger(\n\t\t`\\x20${term.dim(`${hh}:${mm}:${ss}.${ms} ${am}`)}\\x20\\x20` +\n\t\t\t`${dimColor(\"/\")}${color(path_name)}${dimColor(path_ext)} ${dimColor(sep)} ${color(args.status)} ${dimColor(\n\t\t\t\t`(${dur})`,\n\t\t\t)}`,\n\t)\n}\n\nexport function exportEvent(runtime: types.Runtime, meta: types.ServerRouteMeta, start: number): void {\n\tconst { hh, mm, ss, am, ms } = getTimeInfo()\n\n\tconst dur = formatMs(Date.now() - start)\n\n\t// TODO: If we make directories a global variable, we can just reference the\n\t// global object.\n\tconst l1 = runtime.directories.srcPagesDir.length\n\tconst l2 = runtime.directories.exportDir.length\n\n\tlet color = term.white\n\tif (meta.route.type === \"dynamic\") {\n\t\tcolor = term.cyan\n\t}\n\n\tlet dimColor = term.dim.white\n\tif (meta.route.type === \"dynamic\") {\n\t\tdimColor = term.dim.cyan\n\t}\n\n\tconst src = meta.route.src.slice(l1)\n\tconst src_ext = p.extname(src)\n\tconst src_name = src.slice(1, -src_ext.length)\n\n\tconst dst = meta.route.dst.slice(l2)\n\tconst dst_ext = p.extname(dst)\n\tconst dst_name = dst.slice(1, -dst_ext.length)\n\n\tconst sep = \"-\".repeat(Math.max(0, TERM_WIDTH - `/${src_name}${src_ext}\\x20`.length))\n\n\tconsole.log(\n\t\t`\\x20${term.dim(`${hh}:${mm}:${ss}.${ms} ${am}`)}\\x20\\x20` +\n\t\t\t`${dimColor(\"/\")}${color(src_name)}${dimColor(src_ext)} ${dimColor(sep)} ${dimColor(\"/\")}${color(\n\t\t\t\tdst_name,\n\t\t\t)}${dimColor(dst_ext)}${start === 0 ? \"\" : ` ${dimColor(`(${dur})`)}`}`,\n\t)\n}\n", "import * as fs from \"fs\"\nimport * as log from \"../../lib/log\"\nimport * as p from \"path\"\nimport * as term from \"../../lib/term\"\nimport * as types from \"../types\"\n\n// prettier-ignore\ninterface ParsedPath {\n\tsrc:      string // e.g. \"path/to/basename.ext\"\n\tbasename: string // e.g. \"basename.ext\"\n\tname:     string // e.g. \"basename\"\n\text:      string // e.g. \".ext\"\n}\n\n// prettier-ignore\nconst supported: { [key: string]: boolean } = {\n\t\".js\":  true,\n\t\".jsx\": true,\n\t\".ts\":  true,\n\t\".tsx\": true,\n\t\".md\":  true,\n\t\".mdx\": true,\n}\n\n// parsePath parses path metadata so that syntax functions don\u2019t need to\n// re-parse path metadata.\nfunction parsePath(path: string): ParsedPath {\n\tconst basename = p.basename(path)\n\tconst ext = p.extname(path)\n\tconst name = basename.slice(0, -ext.length)\n\treturn { src: path, basename, name, ext }\n}\n\n// src/pages/index.js -> __export__/index.html\n//\n// TODO: Write tests.\nfunction dst(directories: types.DirConfiguration, path: ParsedPath): string {\n\tconst syntax = p.join(directories.exportDir, path.src.slice(directories.srcPagesDir.length))\n\treturn syntax.slice(0, -path.ext.length) + \".html\"\n}\n\n// \"src/pages/component.js\"          -> \"PageComponent\"\n// \"src/pages/nested/component.js\"   -> \"PageNestedComponent\"\n// \"src/pages/[component].js\"        -> \"DynamicPageComponent\"\n// \"src/pages/nested/[component].js\" -> \"DynamicPageNestedComponent\"\n//\n// TODO: Write tests.\nfunction toComponentSyntax(\n\tdirectories: types.DirConfiguration,\n\tparsed: ParsedPath,\n\t{ dynamic }: { dynamic: boolean },\n): string {\n\tlet path = toPathSyntax(directories, parsed)\n\tif (dynamic) {\n\t\t// Remove \"[\" and \"]\":\n\t\tpath = path.replace(dynamicRegex, \"$1$3\")\n\t}\n\tlet syntax = \"\"\n\tfor (const part of path.split(p.sep)) {\n\t\tif (!part.length) continue\n\t\tsyntax += part[0]!.toUpperCase() + part.slice(1)\n\t}\n\tsyntax = syntax || \"Index\"\n\treturn (dynamic ? \"DynamicPage\" : \"Page\") + syntax[0]!.toUpperCase() + syntax.slice(1)\n}\n\n// \"src/pages/index.js\"       -> \"/\"\n// \"src/pages/hello-world.js\" -> \"/hello-world\"\n//\n// TODO: Write tests.\nfunction toPathSyntax(directories: types.DirConfiguration, parsed: ParsedPath): string {\n\tconst syntax = parsed.src.slice(directories.srcPagesDir.length, -parsed.ext.length)\n\tif (syntax.endsWith(\"/index\")) {\n\t\treturn syntax.slice(0, -\"index\".length)\n\t}\n\treturn syntax\n}\n\n// TODO: Write tests.\nfunction createStaticPageMeta(directories: types.DirConfiguration, parsed: ParsedPath): types.StaticPageMeta {\n\tconst component: types.StaticPageMeta = {\n\t\ttype: \"static\",\n\t\tsrc: parsed.src,\n\t\tdst: dst(directories, parsed),\n\t\tpath: toPathSyntax(directories, parsed),\n\t\tcomponent: toComponentSyntax(directories, parsed, { dynamic: false }),\n\t}\n\treturn component\n}\n\n// TODO: Write tests.\nfunction createDynamicPageMeta(directories: types.DirConfiguration, parsed: ParsedPath): types.DynamicPageMeta {\n\tconst component: types.DynamicPageMeta = {\n\t\ttype: \"dynamic\",\n\t\tsrc: parsed.src,\n\t\tcomponent: toComponentSyntax(directories, parsed, { dynamic: true }),\n\t}\n\treturn component\n}\n\n// Matches:\n//\n// - $1 -> \"/\"\n// - $2 -> \"[\"\n// - $3 -> ...\n// - $4 -> \"]\"\n//\n// TODO: Write tests.\nconst dynamicRegex = /(\\/)(\\[)([a-zA-Z0-9\\-\\.\\_\\~\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]+)(\\])/\n\nfunction parsePage(directories: types.DirConfiguration, parsed: ParsedPath): types.PageMeta {\n\tconst path = toPathSyntax(directories, parsed)\n\tif (dynamicRegex.test(path)) {\n\t\treturn createDynamicPageMeta(directories, parsed)\n\t}\n\treturn createStaticPageMeta(directories, parsed)\n}\n\nasync function readdirAll(src: string): Promise<ParsedPath[]> {\n\tconst arr: ParsedPath[] = []\n\tasync function recurse(src: string): Promise<void> {\n\t\tconst ls = await fs.promises.readdir(src)\n\t\tfor (const each of ls) {\n\t\t\tconst path = p.join(src, each)\n\t\t\tif ((await fs.promises.stat(path)).isDirectory()) {\n\t\t\t\tarr.push(parsePath(path))\n\t\t\t\tawait recurse(path)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tarr.push(parsePath(path))\n\t\t}\n\t}\n\tawait recurse(src)\n\treturn arr\n}\n\n// testURICharacter tests whether a character matches URI reserved or unreserved\n// characters based on RFC 3986.\nfunction testURICharacter(char: string): boolean {\n\t// prettier-ignore\n\tif ((char >= \"a\" && char <= \"z\") || // ALPHA LOWER\n\t\t\t(char >= \"A\" && char <= \"Z\") || // ALPHA LOWER\n\t\t\t(char >= \"0\" && char <= \"9\")) { // DIGIT\n\t\treturn true\n\t}\n\t// https://tools.ietf.org/html/rfc3986#section-2.3\n\tswitch (char) {\n\t\tcase \"-\":\n\t\tcase \".\":\n\t\tcase \"_\":\n\t\tcase \"~\":\n\t\t\treturn true\n\t}\n\t// https://tools.ietf.org/html/rfc3986#section-2.2\n\tswitch (char) {\n\t\tcase \":\":\n\t\tcase \"/\":\n\t\tcase \"?\":\n\t\tcase \"#\":\n\t\tcase \"[\":\n\t\tcase \"]\":\n\t\tcase \"@\":\n\t\tcase \"!\":\n\t\tcase \"$\":\n\t\tcase \"&\":\n\t\tcase \"'\":\n\t\tcase \"(\":\n\t\tcase \")\":\n\t\tcase \"*\":\n\t\tcase \"+\":\n\t\tcase \",\":\n\t\tcase \";\":\n\t\tcase \"=\":\n\t\t\treturn true\n\t}\n\treturn false\n}\n\nexport async function parsePages(directories: types.DirConfiguration): Promise<types.PageMeta[]> {\n\tconst arr = await readdirAll(directories.srcPagesDir)\n\n\t// Step over:\n\t//\n\t// - \"_component\"\n\t// - \"$component\"\n\t// - \"component_\"\n\t// - \"component$\"\n\t//\n\t// TODO: Add support for \"layout\" here?\n\tconst arr2 = arr.filter(path => {\n\t\tif (path.name.startsWith(\"_\") || path.name.startsWith(\"$\")) {\n\t\t\treturn false\n\t\t} else if (path.name.endsWith(\"_\") || path.name.endsWith(\"$\")) {\n\t\t\treturn false\n\t\t}\n\t\treturn supported[path.ext] === true\n\t})\n\n\tconst badSrcs: string[] = []\n\tfor (const { src } of arr2) {\n\t\tfor (let x = 0; x < src.length; x++) {\n\t\t\tif (!testURICharacter(src[x]!)) {\n\t\t\t\tbadSrcs.push(src)\n\t\t\t}\n\t\t}\n\t}\n\n\tif (badSrcs.length > 0) {\n\t\t// TODO: Extract to errs?\n\t\tlog.error(`These pages use non-URI characters:\n\n${badSrcs.map(each => \"- \" + each).join(\"\\n\")}\n\nURI characters are described by RFC 3986:\n\n2.2. Unreserved Characters\n\n\tALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\n2.3. Reserved Characters\n\n\tgen-delims = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" /\n\tsub-delims = \"@\" / \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n\t           / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\n${term.underline(\"https://tools.ietf.org/html/rfc3986\")}`)\n\t}\n\n\tconst pages: types.PageMeta[] = []\n\tfor (const parsed of arr2) {\n\t\tpages.push(parsePage(directories, parsed))\n\t}\n\treturn pages\n}\n", "import * as term from \"../lib/term\"\nimport * as types from \"./types\"\n\nexport function missingHeadTemplateTag(path: string): string {\n\treturn `${path}: Add ${term.magenta(\"'%head%'\")} somewhere to ${term.magenta(\"'<head>'\")}.\n\nFor example:\n\n${term.dim(`// ${path}`)}\n...\n<head>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\t${term.magenta(\"%head%\")}\n</head>\n...`\n}\n\nexport function missingPageTemplateTag(path: string): string {\n\treturn `${path}: Add ${term.magenta(\"'%page%'\")} somewhere to ${term.magenta(\"'<body>'\")}.\n\nFor example:\n\n${term.dim(`// ${path}`)}\n...\n<body>\n\t${term.magenta(\"%page%\")}\n</body>\n...`\n}\n\n// prettier-ignore\nexport function serverPropsFunction(src: string): string {\n\treturn `${src}: ${term.magenta(\"'typeof serverProps !== \\\"function\\\"'\")}; ${term.magenta(\"'serverProps'\")} must be a synchronous or an asynchronous function.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverProps() {\n\treturn { ... }\n}\n\nOr:\n\n${term.dim(`// ${src}`)}\nexport async function serverProps() {\n\tawait ...\n\treturn { ... }\n}`\n}\n\n// prettier-ignore\nexport function serverPathsFunction(src: string): string {\n\treturn `${src}: ${term.magenta(\"'typeof serverPaths !== \\\"function\\\"'\")}; ${term.magenta(\"'serverPaths'\")} must be a synchronous or an asynchronous function.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverPaths() {\n\treturn { ... }\n}\n\nOr:\n\n${term.dim(`// ${src}`)}\nexport async function serverPaths() {\n\tawait ...\n\treturn { ... }\n}`\n}\n\nexport function serverPropsMismatch(src: string): string {\n\treturn `${src}: Dynamic pages must use ${term.magenta(\"'serverPaths'\")} not ${term.magenta(\"'serverProps'\")}.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverPaths() {\n\treturn [\n\t\t{ path: \"/foo\", props: ... },\n\t\t{ path: \"/foo/bar\", props: ... },\n\t\t{ path: \"/foo/bar/baz\", props: ... },\n\t]\n}`\n}\n\nexport function serverPropsReturn(src: string): string {\n\treturn `${src}.serverProps: Bad ${term.magenta(\"'serverProps'\")} resolver.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverProps() {\n\treturn { ... }\n}`\n}\n\nexport function serverPathsReturn(src: string): string {\n\treturn `${src}.serverPaths: Bad ${term.magenta(\"'serverPaths'\")} resolver.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverPaths() {\n\treturn [\n\t\t{ path: \"/foo\", props: ... },\n\t\t{ path: \"/foo/bar\", props: ... },\n\t\t{ path: \"/foo/bar/baz\", props: ... },\n\t]\n}`\n}\n\nexport function serverPathsMismatch(src: string): string {\n\treturn `${src}: Non-dynamic pages must use ${term.magenta(\"'serverProps'\")} not ${term.magenta(\"'serverPaths'\")}.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverProps() {\n\treturn { ... }\n}`\n}\n\nexport function duplicatePathFound(r1: types.ServerRoute, r2: types.ServerRoute): string {\n\tfunction caller(r: types.ServerRoute): string {\n\t\treturn r.type === \"static\" ? \"serverProps\" : \"serverPaths\"\n\t}\n\treturn `${r1.src}.${caller(r1)}: Path ${term.magenta(`'${r1.path}'`)} used by ${r2.src}.${caller(r2)}.`\n}\n\n// prettier-ignore\nexport function serveWithoutExport(): string {\n\treturn `It looks like you\u2019re trying to run ${term.magenta(\"'retro serve'\")} before ${term.magenta(\"'retro export'\")}. Try ${term.magenta(\"'retro export && retro serve'\")}.`\n}\n", "import * as errs from \"../errs\"\nimport * as fs from \"fs\"\nimport * as log from \"../../lib/log\"\nimport * as p from \"path\"\nimport * as types from \"../types\"\n\nimport { parsePages } from \"./parsePages\"\n\n// runServerGuards tests for the presence of runtime directories and\n// public/index.html.\nasync function runServerGuards(directories: types.DirConfiguration): Promise<void> {\n\t// prettier-ignore\n\tconst dirs = [\n\t\tdirectories.publicDir,\n\t\tdirectories.srcPagesDir,\n\t\tdirectories.cacheDir,\n\t\tdirectories.exportDir,\n\t]\n\n\t// Guard directories:\n\tfor (const dir of dirs) {\n\t\ttry {\n\t\t\tawait fs.promises.stat(dir)\n\t\t} catch (_) {\n\t\t\tfs.promises.mkdir(dir, { recursive: true })\n\t\t}\n\t}\n\n\t// Guard public/index.html:\n\tconst path = p.join(directories.publicDir, \"index.html\")\n\ttry {\n\t\tconst data = await fs.promises.readFile(path)\n\t\tconst text = data.toString()\n\t\tif (!text.includes(\"%head\")) {\n\t\t\tlog.error(errs.missingHeadTemplateTag(path))\n\t\t} else if (!text.includes(\"%page\")) {\n\t\t\tlog.error(errs.missingPageTemplateTag(path))\n\t\t}\n\t} catch (_) {\n\t\tawait fs.promises.writeFile(\n\t\t\tpath,\n\t\t\t`<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\t\t%head%\n\t</head>\n\t<body>\n\t\t%page%\n\t</body>\n</html>\n`, // EOF\n\t\t)\n\t}\n}\n\nexport async function copyAll(src: string, dst: string, exclude: string[] = []): Promise<void> {\n\tconst directories: string[] = []\n\tconst files: string[] = []\n\n\t// Read directories and files:\n\tasync function recurse(entry: string): Promise<void> {\n\t\tif (exclude.includes(entry)) return\n\n\t\tconst stat = await fs.promises.stat(entry)\n\t\tif (!stat.isDirectory()) {\n\t\t\tfiles.push(entry)\n\t\t} else {\n\t\t\tdirectories.push(entry)\n\t\t\tconst ls = await fs.promises.readdir(entry)\n\t\t\tfor (const each of ls) {\n\t\t\t\tawait recurse(p.join(entry, each))\n\t\t\t}\n\t\t}\n\t}\n\tawait recurse(src)\n\n\t// Copy directories recursively and then copy files:\n\tfor (const directory of directories)\n\t\tawait fs.promises.mkdir(p.join(dst, directory.slice(src.length)), { recursive: true })\n\tfor (const file of files) await fs.promises.copyFile(file, p.join(dst, file.slice(src.length)))\n}\n\nexport async function preflight(runtime: types.Runtime): Promise<void> {\n\t// Run server guards:\n\tawait runServerGuards(runtime.directories)\n\n\t// Purge __export__:\n\tawait fs.promises.rmdir(runtime.directories.exportDir, { recursive: true })\n\tawait copyAll(runtime.directories.publicDir, p.join(runtime.directories.exportDir, runtime.directories.publicDir), [\n\t\tp.join(runtime.directories.publicDir, \"index.html\"),\n\t])\n\n\t// Read runtime.document and runtime.pages:\n\tconst data = await fs.promises.readFile(p.join(runtime.directories.publicDir, \"index.html\"))\n\truntime.document = data.toString()\n\truntime.pages = await parsePages(runtime.directories)\n}\n", "// TODO: Write tests.\nexport function prettyJSON(str: string): string {\n\treturn str.replace(/^{\"/, `{ \"`).replace(/\":\"/g, `\": \"`).replace(/\",\"/g, `\", \"`).replace(/\"}$/, `\" }`)\n}\n", "function validateObject(value: unknown): boolean {\n\treturn typeof value === \"object\" && value !== null && !Array.isArray(value)\n}\n\nfunction validateArray(value: unknown): boolean {\n\treturn typeof value === \"object\" && value !== null && Array.isArray(value)\n}\n\nexport function validateServerPropsReturn(value: unknown): boolean {\n\treturn validateObject(value)\n}\n\nexport function validateServerPathsReturn(value: unknown): boolean {\n\ttype UnknownArray = unknown[]\n\ttype UnknownObject = { [key: string]: unknown }\n\n\t// prettier-ignore\n\tconst ok = validateArray(value) &&\n\t\t(value as UnknownArray).every(each => {\n\t\t\tconst ok = validateObject(each) &&\n\t\t\t\t(\"path\" in (each as UnknownObject) && typeof (each as UnknownObject).path === \"string\") &&\n\t\t\t\t(\"props\" in (each as UnknownObject) && validateServerPropsReturn((each as UnknownObject).props))\n\t\t\treturn ok\n\t\t})\n\treturn ok\n}\n", "import * as fs from \"fs\"\nimport * as p from \"path\"\n\nexport function sleep(ms: number): Promise<void> {\n\treturn new Promise(resolve => setTimeout(resolve, ms))\n}\n\nexport async function* watcher(root: string, { interval }: { interval: number }): AsyncGenerator<string> {\n\tconst mtimeMsMap: { [key: string]: number } = {}\n\n\tasync function read(entry: string, { deep }: { deep: boolean }): Promise<string> {\n\t\tconst stat = await fs.promises.stat(entry)\n\t\tconst mtimeMs = mtimeMsMap[entry]\n\t\tif (mtimeMs === undefined || stat.mtimeMs !== mtimeMs) {\n\t\t\tmtimeMsMap[entry] = stat.mtimeMs\n\t\t\tif (!deep) {\n\t\t\t\treturn entry\n\t\t\t}\n\t\t}\n\t\tif (stat.isDirectory()) {\n\t\t\tfor (const each of await fs.promises.readdir(entry)) {\n\t\t\t\tconst src = p.join(entry, each)\n\t\t\t\tconst result = await read(src, { deep })\n\t\t\t\tif (result !== \"\") {\n\t\t\t\t\tif (!deep) {\n\t\t\t\t\t\treturn result\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tawait read(root, { deep: true })\n\n\t// Generate source changes:\n\twhile (true) {\n\t\tawait sleep(interval)\n\t\tconst src = await read(root, { deep: false })\n\t\tif (src !== \"\") {\n\t\t\tyield src\n\t\t}\n\t}\n}\n", "import * as fs from \"fs\"\nimport * as http from \"http\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\n////////////////////////////////////////////////////////////////////////////////\n\ninterface RenderCache {\n\t[key: string]: {\n\t\tmtimeMs: number\n\t\thtml: string\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nasync function renderToString(): Promise<string> {\n\treturn \"TODO\"\n}\n\n// On start, cache the server-side props and paths.\n// - We need to know server props for Head(serverProps) and Page(serverProps)\n// - We need to know paths / server paths for the HTTP server (respond 200 or 404)\n//\n// On 200 paths, export (w/ serverProps), cache, and serve the page\n// - Use a cache based on mtime to no-op idempotent requests\n// - Emit serve-sent events on esbuild warnings and errors\n//\n// On watch events, rebuild app.js and emit server-sent events (refresh, esbuild warnings and errors)\n//\nconst cmd_dev: types.cmd_dev = async runtime => {\n\tconst router: types.ServerRouter = {}\n\n\t// cache caches HTML based on '(await fs.promises.stat(...)).mtimeMs'.\n\tconst cache: RenderCache = {}\n\n\tlet callback: () => void | undefined\n\n\t// TODO: Generate server router here.\n\t// TODO: Implement esbuild here.\n\n\tasync function watch(): Promise<void> {\n\t\tconst generator = utils.watcher(\"src\", { interval: 100 })\n\t\tasync function next(): Promise<string> {\n\t\t\treturn (await generator.next()).value\n\t\t}\n\n\t\twhile (true) {\n\t\t\tawait next()\n\n\t\t\t// TODO: Regenerate server router here.\n\t\t\t// TODO: Implement esbuild here.\n\n\t\t\tif (callback) callback()\n\t\t}\n\t}\n\n\twatch()\n\n\tconst srv = http.createServer(\n\t\tasync (req: http.IncomingMessage, res: http.ServerResponse): Promise<void> => {\n\t\t\t// Server-sent events:\n\t\t\tif (req.url === \"/~dev\") {\n\t\t\t\tcallback = (): void => {\n\t\t\t\t\t// TODO: Emit a log event here.\n\t\t\t\t\tres.write(\"event: reload\\n\\n\")\n\t\t\t\t}\n\t\t\t\tres.writeHead(200, {\n\t\t\t\t\t\"Content-Type\": \"text/event-stream\",\n\t\t\t\t\t\"Cache-Control\": \"no-cache\",\n\t\t\t\t\tConnection: \"keep-alive\",\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Bad path:\n\t\t\tif (router[req.url!] === undefined) {\n\t\t\t\t// TODO: Emit a log event here.\n\t\t\t\tres.writeHead(404, { \"Content-Type\": \"text/plain\" })\n\t\t\t\tres.end(\"404 - Not Found\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Read from the cache:\n\t\t\tconst stat = await fs.promises.stat(req.url!)\n\t\t\tconst read = cache[req.url!]\n\t\t\tif (read !== undefined && read.mtimeMs !== stat.mtimeMs) {\n\t\t\t\tres.writeHead(200, { \"Content-Type\": \"text/html\" })\n\t\t\t\tres.end(read.html)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Bad cache read; rerender and cache:\n\t\t\tconst html = await renderToString() // TODO\n\t\t\tcache[req.url!] = {\n\t\t\t\tmtimeMs: stat.mtimeMs,\n\t\t\t\thtml,\n\t\t\t}\n\t\t\t// TODO: Emit a log event here (incl. read from the cache or not).\n\t\t\tres.writeHead(200, { \"Content-Type\": \"text/html\" })\n\t\t\tres.end(html)\n\t\t},\n\t)\n\tsrv.listen(runtime.command.port)\n}\n\nexport default cmd_dev\n", "import * as esbuild from \"esbuild\"\nimport * as fs from \"fs\"\nimport * as log from \"../lib/log\"\nimport * as p from \"path\"\nimport * as resolvers from \"./resolvers\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\n// TODO: We need to purge the export directory before write to it.\nconst cmd_export: types.cmd_export = async runtime => {\n\tlet router: types.ServerRouter = {}\n\tif (!runtime.command.cached) {\n\t\trouter = await resolvers.resolveServerRouter(runtime)\n\t\t// TODO: Cache router.\n\t} else {\n\t\t// TODO: Read route from cache.\n\t}\n\n\tconst app = await resolvers.renderServerRouterToString(runtime, router)\n\tconst appPath = p.join(runtime.directories.cacheDir, \"app.js\")\n\tawait fs.promises.writeFile(appPath, app)\n\n\ttry {\n\t\tconst result = await esbuild.build({\n\t\t\tbundle: true,\n\t\t\tdefine: {\n\t\t\t\t__DEV__: process.env.__DEV__!,\n\t\t\t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV),\n\t\t\t},\n\t\t\tentryPoints: [appPath],\n\t\t\tinject: [\"packages/retro/react-shim.js\"],\n\t\t\tloader: { \".js\": \"jsx\" },\n\t\t\tlogLevel: \"silent\", // TODO\n\t\t\tminify: true,\n\t\t\toutfile: p.join(runtime.directories.exportDir, appPath.slice(runtime.directories.srcPagesDir.length)),\n\t\t\t// plugins: [...configs.retro.plugins], // TODO\n\t\t})\n\t\t// TODO: Add support for hints.\n\t\tif (result.warnings.length > 0) {\n\t\t\tfor (const warning of result.warnings) {\n\t\t\t\tlog.warning(utils.formatEsbuildMessage(warning, term.yellow))\n\t\t\t}\n\t\t\tprocess.exit(1)\n\t\t}\n\t} catch (err) {\n\t\t// TODO: How do we differentiate esbuild errors from general errors?\n\t\tlog.error(err)\n\t}\n}\n\nexport default cmd_export\n", "import * as errs from \"./errs\"\nimport * as esbuild from \"esbuild\"\nimport * as fs from \"fs\"\nimport * as log from \"../lib/log\"\nimport * as loggers from \"./utils/logTypes\"\nimport * as p from \"path\"\nimport * as React from \"react\"\nimport * as ReactDOMServer from \"react-dom/server\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\n////////////////////////////////////////////////////////////////////////////////\n\ntype renderToString = (runtime: types.Runtime, meta: types.ServerRouteMeta, mod: types.PageModule) => Promise<void>\n\nexport const renderToString: renderToString = async (runtime, meta, mod) => {\n\tlet head = \"<!-- <Head> -->\"\n\ttry {\n\t\tif (typeof mod.Head === \"function\") {\n\t\t\tconst renderString = ReactDOMServer.renderToStaticMarkup(React.createElement(mod.Head, meta.props))\n\t\t\thead = renderString.replace(/></g, \">\\n\\t\\t<\").replace(/\\/>/g, \" />\")\n\t\t}\n\t} catch (err) {\n\t\tlog.error(`${meta.route.src}.Head: ${err.message}`)\n\t}\n\n\tlet page = `<noscript>You need to enable JavaScript to run this app.</noscript>\n\t\t<div id=\"root\"></div>\n\t\t<script src=\"/app.js\"></script>`\n\ttry {\n\t\tif (typeof mod.default === \"function\") {\n\t\t\tconst renderString = ReactDOMServer.renderToString(React.createElement(mod.default, meta.props))\n\t\t\tpage = page.replace(`<div id=\"root\"></div>`, `<div id=\"root\">${renderString}</div>`)\n\t\t}\n\t} catch (err) {\n\t\tlog.error(`${meta.route.src}.default: ${err.message}`)\n\t}\n\n\t// Export:\n\tconst rendered = runtime.document.replace(\"%head%\", head).replace(\"%page%\", page)\n\tawait fs.promises.mkdir(p.dirname(meta.route.dst), { recursive: true })\n\tawait fs.promises.writeFile(meta.route.dst, rendered)\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\ntype resolveStaticRouteMeta = (\n\truntime: types.Runtime<types.ExportCommand>,\n\tpage: types.StaticPageMeta,\n\toutfile: string,\n) => Promise<types.ServerRouteMeta>\n\nconst resolveStaticRouteMeta: resolveStaticRouteMeta = async (runtime, page, outfile) => {\n\tlet props: types.ServerResolvedProps = { path: page.path }\n\n\t// NOTE: Use try to suppress: warning: This call to \"require\" will not be\n\t// bundled because the argument is not a string literal (surround with a\n\t// try/catch to silence this warning).\n\tlet mod: types.StaticPageModule\n\ttry {\n\t\tmod = require(p.join(\"..\", \"..\", outfile))\n\t} catch {}\n\n\t// Guard serverProps and serverPaths:\n\tif (\"serverProps\" in mod! && typeof mod.serverProps !== \"function\") {\n\t\tlog.error(errs.serverPropsFunction(page.src))\n\t} else if (\"serverPaths\" in mod! && typeof (mod as { [key: string]: unknown }).serverPaths === \"function\") {\n\t\tlog.error(errs.serverPathsMismatch(page.src))\n\t}\n\n\t// Resolve serverProps:\n\tif (typeof mod!.serverProps === \"function\") {\n\t\ttry {\n\t\t\tconst serverProps = await mod!.serverProps!()\n\t\t\tif (!utils.validateServerPropsReturn(serverProps)) {\n\t\t\t\tlog.error(errs.serverPropsReturn(page.src))\n\t\t\t}\n\t\t\tprops = {\n\t\t\t\t// @ts-ignore\n\t\t\t\tpath: page.path, // Add path\n\t\t\t\t...serverProps,\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlog.error(`${page.src}.serverProps: ${err.message}`)\n\t\t}\n\t}\n\n\tconst meta = { route: page, props }\n\tawait renderToString(runtime, meta, mod!)\n\treturn meta\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\ntype resolveDynamicRouteMetas = (\n\truntime: types.Runtime<types.ExportCommand>,\n\tpage: types.PageMeta,\n\toutfile: string,\n) => Promise<types.ServerRouteMeta[]>\n\nconst resolveDynamicRouteMetas: resolveDynamicRouteMetas = async (runtime, page, outfile) => {\n\tconst metas: types.ServerRouteMeta[] = []\n\n\t// NOTE: Use try to suppress: warning: This call to \"require\" will not be\n\t// bundled because the argument is not a string literal (surround with a\n\t// try/catch to silence this warning).\n\tlet mod: types.DynamicPageModule\n\ttry {\n\t\tmod = require(p.join(\"..\", \"..\", outfile))\n\t} catch {}\n\n\t// Guard serverProps and serverPaths:\n\tif (\"serverPaths\" in mod! && typeof mod.serverPaths !== \"function\") {\n\t\tlog.error(errs.serverPathsFunction(page.src))\n\t} else if (\"serverProps\" in mod! && typeof (mod as { [key: string]: unknown }).serverProps === \"function\") {\n\t\tlog.error(errs.serverPropsMismatch(page.src))\n\t}\n\n\t// Resolve serverPaths:\n\tif (typeof mod!.serverPaths === \"function\") {\n\t\tlet paths: { path: string; props: types.Props }[] = []\n\t\ttry {\n\t\t\tpaths = await mod!.serverPaths!()\n\t\t\tif (!utils.validateServerPathsReturn(paths)) {\n\t\t\t\tlog.error(errs.serverPathsReturn(page.src))\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlog.error(`${page.src}.serverPaths: ${err.message}`)\n\t\t}\n\n\t\tfor (const path of paths) {\n\t\t\tconst path_ = p.join(p.dirname(page.src).slice(runtime.directories.srcPagesDir.length), path.path)\n\t\t\tconst dst = p.join(runtime.directories.exportDir, path_ + \".html\")\n\t\t\tmetas.push({\n\t\t\t\troute: {\n\t\t\t\t\ttype: \"dynamic\",\n\t\t\t\t\tsrc: page.src,\n\t\t\t\t\tdst,\n\t\t\t\t\tpath: path_,\n\t\t\t\t\tcomponent: page.component,\n\t\t\t\t},\n\t\t\t\tprops: {\n\t\t\t\t\tpath: path_, // Add path\n\t\t\t\t\t...path.props,\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\tfor (const meta of metas) {\n\t\tawait renderToString(runtime, meta, mod!)\n\t}\n\treturn metas\n}\n\nlet once = false\n\n////////////////////////////////////////////////////////////////////////////////\n\ntype resolveServerRouter = (runtime: types.Runtime<types.ExportCommand>) => Promise<types.ServerRouter>\n\n// resolveServerRouter exports pages and resolves the server router; resolves\n// mod.serverProps and mod.serverPaths.\n//\n// TODO: Extract middleware so loggers can be externalized?\nexport const resolveServerRouter: resolveServerRouter = async runtime => {\n\tconst router: types.ServerRouter = {}\n\n\t// TODO: Add --concurrent?\n\tconst service = await esbuild.startService()\n\tfor (const page of runtime.pages) {\n\t\t// Generate paths for esbuild:\n\t\tconst entryPoints = [page.src]\n\t\tconst outfile = p.join(runtime.directories.cacheDir, page.src.replace(/\\.(jsx?|tsx?|mdx?)$/, \".esbuild.js\"))\n\n\t\t// let result: esbuild.BuildResult\n\t\ttry {\n\t\t\t// Use external: [\"react\", \"react-dom\"] to prevent a React error: You\n\t\t\t// might have mismatching versions of React and the renderer (such as\n\t\t\t// React DOM).\n\t\t\tconst result = await service.build({\n\t\t\t\tbundle: true,\n\t\t\t\tdefine: {\n\t\t\t\t\t__DEV__: process.env.__DEV__!,\n\t\t\t\t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV!),\n\t\t\t\t},\n\t\t\t\tentryPoints,\n\t\t\t\texternal: [\"react\", \"react-dom\"],\n\t\t\t\tformat: \"cjs\", // Node.js\n\t\t\t\tinject: [\"packages/retro/react-shim.js\"],\n\t\t\t\tloader: { \".js\": \"jsx\" },\n\t\t\t\tlogLevel: \"silent\", // TODO\n\t\t\t\toutfile,\n\t\t\t\t// plugins: [...configs.retro.plugins], // TODO\n\t\t\t})\n\t\t\t// TODO: Add support for hints.\n\t\t\tif (result.warnings.length > 0) {\n\t\t\t\tfor (const warning of result.warnings) {\n\t\t\t\t\tlog.warning(utils.formatEsbuildMessage(warning, term.yellow))\n\t\t\t\t}\n\t\t\t\tprocess.exit(1)\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t// TODO: How do we differentiate esbuild errors from general errors?\n\t\t\tlog.error(utils.formatEsbuildMessage((err as esbuild.BuildFailure).errors[0]!, term.bold.red))\n\t\t}\n\n\t\t// Resolve static page:\n\t\tlet start = Date.now()\n\t\tif (page.type === \"static\") {\n\t\t\tconst meta = await resolveStaticRouteMeta(runtime, page, outfile)\n\t\t\tif (router[meta.route.path] !== undefined) {\n\t\t\t\tlog.error(errs.duplicatePathFound(meta.route, router[meta.route.path]!.route))\n\t\t\t}\n\t\t\trouter[meta.route.path] = meta\n\t\t\tif (!once) {\n\t\t\t\tconsole.log()\n\t\t\t\tonce = true\n\t\t\t}\n\t\t\tloggers.exportEvent(runtime, meta, start)\n\t\t}\n\n\t\t// Resolve dynamic pages:\n\t\tif (page.type === \"dynamic\") {\n\t\t\tconst metas = await resolveDynamicRouteMetas(runtime, page, outfile)\n\n\t\t\tfor (const meta of metas) {\n\t\t\t\tif (router[meta.route.path] !== undefined) {\n\t\t\t\t\tlog.error(errs.duplicatePathFound(meta.route, router[meta.route.path]!.route))\n\t\t\t\t}\n\t\t\t\trouter[meta.route.path] = meta\n\t\t\t\tif (!once) {\n\t\t\t\t\tconsole.log()\n\t\t\t\t\tonce = true\n\t\t\t\t}\n\t\t\t\tloggers.exportEvent(runtime, meta, start)\n\t\t\t\tstart = 0 // No-op\n\t\t\t}\n\t\t}\n\t}\n\n\tconsole.log()\n\treturn router\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\ntype renderServerRouterToString = (\n\truntime: types.Runtime<types.ExportCommand>,\n\trouter: types.ServerRouter,\n) => Promise<string>\n\n// TODO: Write tests (pure function).\nexport const renderServerRouterToString: renderServerRouterToString = async (runtime, router) => {\n\tconst distinctComponents = [...new Set(runtime.pages.map(each => each.component))] // TODO: Change to router?\n\n\tconst distinctRoutes = runtime.pages\n\t\t.filter(route => distinctComponents.includes(route.component))\n\t\t.sort((a, b) => a.component.localeCompare(b.component))\n\n\treturn `import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport { Route, Router } from \"../packages/router\"\n\n// Components\n${distinctRoutes.map(route => `import ${route.component} from \"../${route.src}\"`).join(\"\\n\")}\n\nexport default function App() {\n\treturn (\n\t\t<Router>\n${\n\tObject.entries(router)\n\t\t.map(\n\t\t\t([path, meta]) => `\n\t\t\t<Route path=\"${path}\">\n\t\t\t\t<${meta.route.component}\n\t\t\t\t\t{...${utils.prettyJSON(JSON.stringify(meta.props))}\n\t\t\t\t} />\n\t\t\t</Route>`,\n\t\t)\n\t\t.join(\"\\n\") + \"\\n\"\n}\n\t\t</Router>\n\t)\n}\n\n${\n\tJSON.parse(process.env.STRICT_MODE || \"true\")\n\t\t? `ReactDOM.${JSON.parse(process.env.RENDER || \"false\") ? \"render\" : \"hydrate\"}(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById(\"root\"),\n)`\n\t\t: `ReactDOM.${JSON.parse(process.env.RENDER || \"false\") ? \"render\" : \"hydrate\"}(\n\t<App />,\n\tdocument.getElementById(\"root\"),\n)`\n}\n`\n}\n", "import * as errs from \"./errs\"\nimport * as esbuild from \"esbuild\"\nimport * as fs from \"fs\"\nimport * as http from \"http\"\nimport * as log from \"../lib/log\"\nimport * as loggers from \"./utils/logTypes\"\nimport * as p from \"path\"\nimport * as types from \"./types\"\n\n// spaify converts a URL for SPA-mode.\n//\n// TODO: Write tests.\nfunction spaify(_: string): string {\n\treturn \"/\"\n}\n\n// ssgify converts a URL for SSG-mode.\n//\n// TODO: Write tests.\nfunction ssgify(url: string): string {\n\tif (url.endsWith(\"/\")) return url + \"index.html\"\n\tif (p.extname(url) === \"\") return url + \".html\"\n\treturn url\n}\n\nconst serve: types.cmd_serve = async runtime => {\n\ttry {\n\t\tawait fs.promises.stat(\"__export__\")\n\t} catch {\n\t\tlog.error(errs.serveWithoutExport)\n\t}\n\n\t// prettier-ignore\n\tconst result = await esbuild.serve({\n\t\tservedir: runtime.directories.exportDir,\n\t\tonRequest: (args: esbuild.ServeOnRequestArgs) => loggers.serveEvent(args),\n\t}, {})\n\n\tlet transformURL = ssgify\n\tif (runtime.command.mode === \"spa\") {\n\t\ttransformURL = spaify\n\t}\n\n\t// This implementation is roughly based on:\n\t//\n\t// - https://esbuild.github.io/api/#customizing-server-behavior\n\t// - https://github.com/evanw/esbuild/issues/858#issuecomment-782814216\n\t//\n\tconst srvProxy = http.createServer((req, res) => {\n\t\tconst options = {\n\t\t\thostname: result.host,\n\t\t\tport: result.port,\n\t\t\tpath: transformURL(req.url!),\n\t\t\tmethod: req.method,\n\t\t\theaders: req.headers,\n\t\t}\n\t\tconst reqProxy = http.request(options, resProxy => {\n\t\t\t// Bad request:\n\t\t\tif (resProxy.statusCode === 404) {\n\t\t\t\tres.writeHead(404, { \"Content-Type\": \"text/plain\" })\n\t\t\t\tres.end(\"404 - Not Found\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// OK request:\n\t\t\tres.writeHead(resProxy.statusCode!, resProxy.headers)\n\t\t\tresProxy.pipe(res, { end: true })\n\t\t})\n\t\treq.pipe(reqProxy, { end: true })\n\t})\n\tsrvProxy.listen(runtime.command.port)\n}\n\nexport default serve\n", "import * as log from \"../lib/log\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\nimport cmd_dev from \"./cmd_dev\"\nimport cmd_export from \"./cmd_export\"\nimport cmd_serve from \"./cmd_serve\"\n\nconst usage = `${term.bold(\"Usage:\")}\n\n\\x20\\x20retro dev        Start the dev server\n\\x20\\x20retro export     Export the production-ready build (SSG)\n\\x20\\x20retro serve      Serve the production-ready build\n\n${term.bold(\"retro dev\")}\n\n\\x20\\x20Start the dev server\n\n\\x20\\x20--cached=...     Use cached resources (default false)\n\\x20\\x20--sourcemap=...  Add source maps (default true)\n\\x20\\x20--port=...       Port number (default 8000)\n\n${term.bold(\"retro export\")}\n\n\\x20\\x20Export the production-ready build (SSG)\n\n\\x20\\x20--cached=...     Use cached resources (default false)\n\\x20\\x20--sourcemap=...  Add source maps (default true)\n\n${term.bold(\"retro serve\")}\n\n\\x20\\x20Serve the production-ready build\n\n\\x20\\x20--mode=...       Serve mode 'spa' or 'ssg' (default 'ssg')\n\\x20\\x20--port=...       Port number (default 8000)\n\n${term.bold(\"Repository\")}\n\n\\x20\\x20${term.underline(\"https://github.com/zaydek/retro\")}\n`\n\nconst cmds = `\nretro dev     Start the dev server\nretro export  Export the production-ready build (SSG)\nretro serve   Serve the production-ready build\n`.trim()\n\n// parseDevCommandFlags parses 'retro dev [flags]'.\n//\n// TODO: Write tests.\nfunction parseDevCommandFlags(...args: string[]): types.DevCommand {\n\tconst cmd: types.DevCommand = {\n\t\ttype: \"dev\",\n\t\tcached: false,\n\t\tsourcemap: true,\n\t\tport: 8000,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\tif (arg === \"--cached\") {\n\t\t\t\tcmd.cached = true\n\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\tcmd.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--cached\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\tcmd.sourcemap = true\n\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\tcmd.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--sourcemap\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--port\")) {\n\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\tcmd.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--port\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command ${term.magenta(`'${badCmd}'`)}. You can use ${term.magenta(\"'retro help'\")} for help.`)\n\t}\n\tif (cmd.port < 1e3 || cmd.port >= 1e4) {\n\t\tlog.error(`${term.magenta(\"'--port'\")} must be between 1000-9999.`)\n\t}\n\treturn cmd\n}\n\n// parseExportCommandFlags parses 'retro export [flags]'.\n//\n// TODO: Write tests.\nfunction parseExportCommandFlags(...args: string[]): types.ExportCommand {\n\tconst cmd: types.ExportCommand = {\n\t\ttype: \"export\",\n\t\tcached: false,\n\t\tsourcemap: true,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\tif (arg === \"--cached\") {\n\t\t\t\tcmd.cached = true\n\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\tcmd.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--cached\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\tcmd.sourcemap = true\n\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\tcmd.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--sourcemap\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command ${term.magenta(`'${badCmd}'`)}. You can use ${term.magenta(\"'retro help'\")} for help.`)\n\t}\n\treturn cmd\n}\n\n// parseServeCommandFlags parses 'retro serve [flags]'.\n//\n// TODO: Write tests.\nfunction parseServeCommandFlags(...args: string[]): types.ServeCommand {\n\tconst cmd: types.ServeCommand = {\n\t\ttype: \"serve\",\n\t\tmode: \"ssg\",\n\t\tport: 8000,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--mode\")) {\n\t\t\tif (arg === \"--mode=spa\") {\n\t\t\t\tcmd.mode = \"spa\"\n\t\t\t} else if (arg === \"--mode=ssg\") {\n\t\t\t\tcmd.mode = \"ssg\"\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--mode\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--port\")) {\n\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\tcmd.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--port\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command ${term.magenta(`'${badCmd}'`)}. You can use ${term.magenta(\"'retro help'\")} for help.`)\n\t}\n\tif (cmd.port < 1e3 || cmd.port >= 1e4) {\n\t\tlog.error(`${term.magenta(\"'--port'\")} must be between 1000-9999.`)\n\t}\n\treturn cmd\n}\n\n// // cmd returns the command used.\n// function cmd(): string {\n// \tconst args = process.argv0 === \"node\" ? process.argv.slice(1) : process.argv\n// \treturn `retro ${args.slice(1).join(\" \")}`\n// }\n\nasync function run(): Promise<void> {\n\tconst args = process.argv0 === \"node\" ? process.argv.slice(1) : process.argv\n\n\t// Cover [\"retro\"] case:\n\tif (args.length === 1) {\n\t\tconsole.log(usage.replace(\"\\t\", \" \".repeat(2)))\n\t\tprocess.exit(0)\n\t}\n\n\tlet command: types.Command\n\tconst arg = args[1]\n\tif (arg === \"version\" || arg === \"--version\" || arg === \"--v\") {\n\t\tconsole.log(process.env[\"RETRO_VERSION\"] || \"TODO\")\n\t\tprocess.exit(0)\n\t} else if (arg === \"usage\" || arg === \"--usage\" || arg === \"help\" || arg === \"--help\") {\n\t\tconsole.log(usage.replace(\"\\t\", \" \".repeat(2)))\n\t\tprocess.exit(0)\n\t} else if (arg === \"dev\") {\n\t\tprocess.env[\"__DEV__\"] = \"true\"\n\t\tprocess.env[\"NODE_ENV\"] = \"development\"\n\t\tcommand = parseDevCommandFlags(...args.slice(2))\n\t} else if (arg === \"export\") {\n\t\tprocess.env[\"__DEV__\"] = \"false\"\n\t\tprocess.env[\"NODE_ENV\"] = \"production\"\n\t\tcommand = parseExportCommandFlags(...args.slice(2))\n\t} else if (arg === \"serve\") {\n\t\tprocess.env[\"__DEV__\"] = \"false\"\n\t\tprocess.env[\"NODE_ENV\"] = \"production\"\n\t\tcommand = parseServeCommandFlags(...args.slice(2))\n\t} else {\n\t\tlog.error(`No such command ${term.magenta(`'${arg}'`)}.\n\nSupported commands:\n\n${\n\tcmds\n\t// .split(\"\\n\")\n\t// .map(each => \"\\x20\\x20\" + each)\n\t// .join(\"\\n\")\n}\n\n${term.yellow(\"hint:\")} Use ${term.magenta(\"'retro usage'\")} for usage.`)\n\t}\n\n\t// prettier-ignore\n\tconst runtime: types.Runtime = {\n\t\tcommand: command!,\n\t\tdirectories: {\n\t\t\tpublicDir:   process.env.PUBLIC_DIR || \"public\",\n\t\t\tsrcPagesDir: process.env.PAGES_DIR  || \"src/pages\",\n\t\t\tcacheDir:    process.env.CACHE_DIR  || \"__cache__\",\n\t\t\texportDir:   process.env.EXPORT_DIR || \"__export__\",\n\t\t},\n\t\tdocument: \"\", // Defer to dev and export\n\t\tpages: [],    // Defer to dev and export\n\t}\n\n\tif (runtime.command.type === \"dev\") {\n\t\tawait utils.preflight(runtime)\n\t\tawait cmd_dev(runtime as types.Runtime<types.DevCommand>)\n\t} else if (runtime.command.type === \"export\") {\n\t\tawait utils.preflight(runtime)\n\t\tawait cmd_export(runtime as types.Runtime<types.ExportCommand>)\n\t} else if (runtime.command.type === \"serve\") {\n\t\tawait cmd_serve(runtime as types.Runtime<types.ServeCommand>)\n\t}\n}\n\nprocess.on(\"uncaughtException\", (err: Error): void => {\n\tprocess.env[\"STACK_TRACE\"] = \"true\"\n\terr.message = `UncaughtException: ${err.message}`\n\tlog.error(err)\n})\n\nrun()\n"],
  "mappings": "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",
  "names": []
}
