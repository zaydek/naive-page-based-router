{
  "version": 3,
  "sources": ["cli.ts", "../lib/term.ts", "../lib/log.ts", "utils.ts", "guards.ts", "commands/export_.ts", "commands/serve.ts"],
  "sourcesContent": ["import * as log from \"../lib/log\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\n// TODO: Should we 'export * from \"./commands\"'?\nimport export_ from \"./commands/export_\"\nimport serve from \"./commands/serve\"\n\nexport const cmds = `\nretro dev     Start the dev server\nretro export  Export the production-ready build (SSG)\nretro serve   Serve the production-ready build\n`.trim()\n\n// NOTE: Use spaces here.\nexport const usage = `${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n  ${term.bold(\"Usage:\")}\n\n    retro dev     Start the dev server\n    retro export  Export the production-ready build (SSG)\n    retro serve   Serve the production-ready build\n\n  ${term.bold(\"retro dev\")}\n\n    Start the dev server\n\n      --cached=...     Use cached resources (default false)\n      --sourcemap=...  Add source maps (default true)\n      --port=...       Port number (default 8000)\n\n  ${term.bold(\"retro export\")}\n\n    Export the production-ready build (SSG)\n\n      --cached=...     Use cached resources (default false)\n      --sourcemap=...  Add source maps (default true)\n\n  ${term.bold(\"retro serve\")}\n\n    Serve the production-ready build\n\n      --mode=...       Serve mode 'spa' or 'ssg' (default 'ssg')\n      --port=...       Port number (default 8000)\n\n  ${term.bold(\"Repository:\")}\n\n    ${term.underline(\"https://github.com/zaydek/retro\")}\n`\n\n// parseDevCommandFlags parses 'retro dev [flags]'.\n//\n// TODO: Write tests.\nfunction parseDevCommandFlags(...args: string[]): types.DevCommand {\n\tconst cmd: types.DevCommand = {\n\t\ttype: \"dev\",\n\t\tcached: false,\n\t\tsourcemap: true,\n\t\tport: 8000,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\tif (arg === \"--cached\") {\n\t\t\t\tcmd.cached = true\n\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\tcmd.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--cached\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\tcmd.sourcemap = true\n\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\tcmd.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--sourcemap\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--port\")) {\n\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\tcmd.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--port\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\tif (cmd.port < 1e3 || cmd.port >= 1e4) {\n\t\tlog.error(\"'--port' must be between 1000-9999.\")\n\t}\n\treturn cmd\n}\n\n// parseExportCommandFlags parses 'retro export [flags]'.\n//\n// TODO: Write tests.\nfunction parseExportCommandFlags(...args: string[]): types.ExportCommand {\n\tconst cmd: types.ExportCommand = {\n\t\ttype: \"export\",\n\t\tcached: false,\n\t\tsourcemap: true,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\tif (arg === \"--cached\") {\n\t\t\t\tcmd.cached = true\n\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\tcmd.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--cached\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\tcmd.sourcemap = true\n\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\tcmd.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--sourcemap\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\treturn cmd\n}\n\n// parseServeCommandFlags parses 'retro serve [flags]'.\n//\n// TODO: Write tests.\nfunction parseServeCommandFlags(...args: string[]): types.ServeCommand {\n\tconst cmd: types.ServeCommand = {\n\t\ttype: \"serve\",\n\t\tmode: \"ssg\",\n\t\tport: 8000,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--mode\")) {\n\t\t\tif (arg === \"--mode=spa\") {\n\t\t\t\tcmd.mode = \"spa\"\n\t\t\t} else if (arg === \"--mode=ssg\") {\n\t\t\t\tcmd.mode = \"ssg\"\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--mode\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--port\")) {\n\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\tcmd.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--port\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\tif (cmd.port < 1e3 || cmd.port >= 1e4) {\n\t\tlog.error(\"'--port' must be between 1000-9999.\")\n\t}\n\treturn cmd\n}\n\n// prettier-ignore\nconst DIR_CONFIGURATION = {\n  publicDir:   process.env.PUBLIC_DIR || \"public\",\n  srcPagesDir: process.env.PAGES_DIR  || \"src/pages\",\n  cacheDir:    process.env.CACHE_DIR  || \"__cache__\",\n  exportDir:   process.env.EXPORT_DIR || \"__export__\",\n}\n\nasync function run(): Promise<void> {\n\tconst args = process.argv0 === \"node\" ? process.argv.slice(1) : process.argv\n\n\t// Cover [\"retro\"] case:\n\tif (args.length === 1) {\n\t\tconsole.log(usage)\n\t\tprocess.exit(0)\n\t}\n\n\tlet cmd: types.Command\n\tconst arg = args[1]\n\tif (arg === \"version\" || arg === \"--version\" || arg === \"--v\") {\n\t\tconsole.log(process.env[\"RETRO_VERSION\"] || \"TODO\")\n\t\tprocess.exit(0)\n\t} else if (arg === \"usage\" || arg === \"--usage\" || arg === \"help\" || arg === \"--help\") {\n\t\tconsole.log(usage)\n\t\tprocess.exit(0)\n\t} else if (arg === \"dev\") {\n\t\tprocess.env[\"__DEV__\"] = \"true\"\n\t\tprocess.env[\"NODE_ENV\"] = \"development\"\n\t\tcmd = parseDevCommandFlags(...args.slice(2))\n\t} else if (arg === \"export\") {\n\t\tprocess.env[\"__DEV__\"] = \"false\"\n\t\tprocess.env[\"NODE_ENV\"] = \"production\"\n\t\tcmd = parseExportCommandFlags(...args.slice(2))\n\t} else if (arg === \"serve\") {\n\t\tprocess.env[\"__DEV__\"] = \"false\"\n\t\tprocess.env[\"NODE_ENV\"] = \"production\"\n\t\tcmd = parseServeCommandFlags(...args.slice(2))\n\t} else {\n\t\tlog.error(`No such command '${arg}'. Use one of these commands:\n\n${cmds}\n\nOr use 'retro usage' for usage.`)\n\t}\n\n\tconst runtime: types.Runtime = {\n\t\tcmd: cmd!,\n\t\tdir: DIR_CONFIGURATION,\n\t\trouter: [],\n\t}\n\n\tswitch (cmd!.type) {\n\t\tcase \"dev\":\n\t\t\t// TODO\n\t\t\tbreak\n\t\tcase \"export\":\n\t\t\tconst r2 = runtime as types.Runtime<types.ExportCommand>\n\t\t\tawait export_(r2)\n\t\t\tbreak\n\t\tcase \"serve\":\n\t\t\tconst r3 = runtime as types.Runtime<types.ServeCommand>\n\t\t\tawait serve(r3)\n\t\t\tbreak\n\t}\n}\n\nprocess.on(\"uncaughtException\", err => {\n\tutils.setWillEagerlyTerminate(true)\n\tprocess.env[\"STACK_TRACE\"] = \"true\" // Force on\n\terr.message = `UncaughtException: ${err.message}.`\n\tlog.error(err)\n})\n\nrun()\n", "export const reset = `\\x1b[0m`\nexport const bold = (...args: unknown[]): string => `\\x1b[0;1m${args.join(\" \")}${reset}`\nexport const gray = (...args: unknown[]): string => `\\x1b[0;2m${args.join(\" \")}${reset}`\nexport const underline = (...args: unknown[]): string => `\\x1b[0;4m${args.join(\" \")}${reset}`\nexport const black = (...args: unknown[]): string => `\\x1b[0;30m${args.join(\" \")}${reset}`\nexport const red = (...args: unknown[]): string => `\\x1b[0;31m${args.join(\" \")}${reset}`\nexport const green = (...args: unknown[]): string => `\\x1b[0;32m${args.join(\" \")}${reset}`\nexport const yellow = (...args: unknown[]): string => `\\x1b[0;33m${args.join(\" \")}${reset}`\nexport const purple = (...args: unknown[]): string => `\\x1b[0;34m${args.join(\" \")}${reset}`\nexport const magenta = (...args: unknown[]): string => `\\x1b[0;35m${args.join(\" \")}${reset}`\nexport const teal = (...args: unknown[]): string => `\\x1b[0;36m${args.join(\" \")}${reset}`\nexport const white = (...args: unknown[]): string => `\\x1b[0;37m${args.join(\" \")}${reset}`\nexport const boldUnderline = (...args: unknown[]): string => `\\x1b[1;4m${args.join(\" \")}${reset}`\nexport const boldBlack = (...args: unknown[]): string => `\\x1b[1;30m${args.join(\" \")}${reset}`\nexport const boldRed = (...args: unknown[]): string => `\\x1b[1;31m${args.join(\" \")}${reset}`\nexport const boldGreen = (...args: unknown[]): string => `\\x1b[1;32m${args.join(\" \")}${reset}`\nexport const boldYellow = (...args: unknown[]): string => `\\x1b[1;33m${args.join(\" \")}${reset}`\nexport const boldPurple = (...args: unknown[]): string => `\\x1b[1;34m${args.join(\" \")}${reset}`\nexport const boldMagenta = (...args: unknown[]): string => `\\x1b[1;35m${args.join(\" \")}${reset}`\nexport const boldTeal = (...args: unknown[]): string => `\\x1b[1;36m${args.join(\" \")}${reset}`\nexport const boldWhite = (...args: unknown[]): string => `\\x1b[1;37m${args.join(\" \")}${reset}`\n", "import * as term from \"./term\"\n\n// prettier-ignore\nfunction formatMessage(msg: string): string {\n\treturn msg.split(\"\\n\").map((each, x) => {\n\t\tif (x === 0) return each\n\t\tif (each === \"\") return each\n\t\treturn \" \".repeat(2) + each.replace(\"\\t\", \"  \")\n\t}).join(\"\\n\")\n}\n\nexport function info(...args: unknown[]): void {\n\tconst message = formatMessage(args.join(\" \"))\n\n\tconsole.log(`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n${\" \".repeat(2)}${term.bold(\">\")} ${term.boldGreen(\"ok:\")} ${term.bold(message)}\n`)\n}\n\n// TODO: Can we support (...args: unknown[]) here?\nexport function error(error: string | Error): void {\n\tconst message = formatMessage(typeof error === \"object\" ? error.message : error)\n\n\tconst traceEnabled = process.env[\"STACK_TRACE\"] === \"true\"\n\tif (!traceEnabled) {\n\t\tconsole.error(`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n${\" \".repeat(2)}${term.bold(\">\")} ${term.boldRed(\"error:\")} ${term.bold(message)}\n`)\n\t} else {\n\t\tconsole.error(`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n${\" \".repeat(2)}${term.bold(\">\")} ${term.boldRed(\"error:\")} ${term.bold(message)}\n`)\n\t\tconsole.error({ error })\n\t}\n\tprocess.exit(0)\n}\n", "import readline from \"readline\"\n\nlet willEagerlyTerminate = false\n\n// getWillEagerlyTerminate gets whether the runtime will eagerly terminate.\nexport function getWillEagerlyTerminate(): boolean {\n\treturn willEagerlyTerminate\n}\n\n// setWillEagerlyTerminate sets whether the runtime will eagerly terminate.\nexport function setWillEagerlyTerminate(t: boolean): void {\n\twillEagerlyTerminate = t\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// https://gist.github.com/timneutkens/f2933558b8739bbf09104fb27c5c9664\nexport function clearScreen(): void {\n\tconst emptyScreen = \"\\n\".repeat(process.stdout.rows)\n\tconsole.log(emptyScreen)\n\treadline.cursorTo(process.stdout, 0, 0)\n\treadline.clearScreenDown(process.stdout)\n}\n", "import * as fs from \"fs\"\nimport * as log from \"../lib/log\"\nimport * as p from \"path\"\nimport * as types from \"./types\"\n\n// runServerGuards tests for the presence of directories and public/index.html.\nexport default async function runServerGuards(dir: types.DirConfiguration): Promise<void> {\n\tconst dirs = Object.entries(dir).map(([_, v]) => v)\n\n\t// Guards directories:\n\tfor (const dir_ of dirs) {\n\t\ttry {\n\t\t\tawait fs.promises.stat(dir_)\n\t\t} catch (_) {\n\t\t\tfs.promises.mkdir(dir_, { recursive: true })\n\t\t}\n\t}\n\n\t// Guards public/index.html:\n\tconst path = p.join(dir.publicDir, \"index.html\")\n\ttry {\n\t\tconst data = await fs.promises.readFile(path)\n\t\tconst text = data.toString()\n\t\tif (!text.includes(\"%head\")) {\n\t\t\tlog.error(`${path}: Add '%head%' somewhere to '<head>'.\n\nFor example:\n\n...\n<head>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\t%head%\n</head>\n...`)\n\t\t} else if (!text.includes(\"%app\")) {\n\t\t\tlog.error(`${path}: Add '%app%' somewhere to '<body>'.\n\nFor example:\n\n...\n<body>\n\t<noscript>You need to enable JavaScript to run this app.</noscript>\n\t<div id=\"app\"></div>\n\t%app%\n</body>\n...`)\n\t\t}\n\t} catch (_) {\n\t\tawait fs.promises.writeFile(\n\t\t\tpath,\n\t\t\t`<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"utf-8\" />\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\t\t%head%\n\t</head>\n\t<body>\n\t\t<noscript>You need to enable JavaScript to run this app.</noscript>\n\t\t<div id=\"app\"></div>\n\t\t%app%\n\t</body>\n</html>\n`,\n\t\t)\n\t}\n}\n", "// import * as esbuild from \"esbuild\"\n// import * as fs from \"fs\"\n// import * as p from \"path\"\n// import * as React from \"react\"\n// import * as ReactDOMServer from \"react-dom/server\"\n\nimport * as types from \"../types\"\n\nimport runServerGuards from \"../guards\"\n\n// // RenderPayload describes a render payload (page metadata).\n// interface RenderPayload {\n// \toutputPath: string\n// \tpath: string\n// \tmodule: types.StaticPageModule | types.DynamicPageModule\n// \tprops?: types.DescriptiveServerProps\n// }\n//\n// // \"/\" -> \"/index.html\"\n// // \"/nested/\" -> \"/nested/index.html\"\n// function pathToHTML(path: string): string {\n// \tif (!path.endsWith(\"/\")) return path + \".html\"\n// \treturn path + \"index.html\"\n// }\n//\n// // exportPage exports a page.\n// async function exportPage(runtime: types.Runtime, render: RenderPayload): Promise<void> {\n// \t// Render head:\n// \tlet head = \"<!-- <Head> -->\"\n// \tif (typeof render.module.Head === \"function\") {\n// \t\tconst markup = ReactDOMServer.renderToStaticMarkup(React.createElement(render.module.Head, render.props))\n// \t\thead = markup.replace(/></g, \">\\n\\t\\t<\").replace(/\\/>/g, \" />\")\n// \t}\n//\n// \t// Render page:\n// \tlet page = `\n// \t\t<noscript>You need to enable JavaScript to run this app.</noscript>\n// \t\t<div id=\"root\"></div>\n// \t\t<script src=\"/app.js\"></script>\n// \t`.trim()\n//\n// \t// prettier-ignore\n// \tif (typeof render.module.default === \"function\") {\n// \t\tconst str = ReactDOMServer.renderToString(React.createElement(render.module.default, render.props))\n// \t\tpage = page.replace(\n// \t\t\t`<div id=\"root\"></div>`,\n// \t\t\t`<div id=\"root\">${str}</div>`,\n// \t\t)\n// \t}\n//\n// \t// prettier-ignore\n// \tconst data = runtime.baseHTML\n// \t\t.replace(\"%head%\", head)\n// \t\t.replace(\"%page%\", page)\n//\n// \t// Export:\n// \tawait fs.promises.mkdir(p.dirname(render.outputPath), { recursive: true })\n// \tawait fs.promises.writeFile(render.outputPath, data)\n// }\n//\n// // exportPagesAndCreateRouter exports pages and creates a router from the return\n// // of mod.serverProps and mod.serverPaths.\n// async function exportPagesAndCreateRouter(runtime: types.Runtime): Promise<types.ServerRouter> {\n// \tconst router: types.ServerRouter = {}\n//\n// \tconst service = await esbuild.startService()\n//\n// \t// TODO: Add --concurrent?\n// \tfor (const route of runtime.filesystemRouter) {\n// \t\t// Generate paths for esbuild:\n// \t\tconst entryPoints = [route.inputPath]\n// \t\tconst outfile = p.join(\n// \t\t\truntime.directoryConfiguration.cacheDir,\n// \t\t\tentryPoints[0]!.replace(/\\.(jsx?|tsx?)$/, \".esbuild.js\"),\n// \t\t)\n//\n// \t\t// Use external: [\"react\", \"react-dom\"] to prevent a React error: You might\n// \t\t// have mismatching versions of React and the renderer (such as React DOM).\n// \t\tawait service.build({\n// \t\t\tbundle: true,\n// \t\t\tdefine: {\n// \t\t\t\t__DEV__: process.env.__DEV__!,\n// \t\t\t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV),\n// \t\t\t},\n// \t\t\tentryPoints,\n// \t\t\texternal: [\"react\", \"react-dom\"],\n// \t\t\tformat: \"cjs\", // Node.js\n// \t\t\tinject: [\"scripts/react-shim.js\"],\n// \t\t\tloader: { \".js\": \"jsx\" },\n// \t\t\tlogLevel: \"silent\", // TODO\n// \t\t\toutfile,\n// \t\t\t// plugins: [...configs.retro.plugins], // TODO\n// \t\t})\n// \t\t// TODO: Handle warnings, error, and hints.\n//\n// \t\tconst mod = require(\"../\" + outfile)\n//\n// \t\t// TODO: Add cache check here.\n//\n// \t\tlet descriptSrvProps: types.DescriptiveServerProps = { path: route.path }\n// \t\tif (typeof mod.serverProps === \"function\") {\n// \t\t\tconst props = await mod.serverProps()\n// \t\t\tdescriptSrvProps = {\n// \t\t\t\tpath: route.path, // Add path\n// \t\t\t\t...props,\n// \t\t\t}\n// \t\t}\n//\n// \t\t// TODO: Warn here for non-dynamic filesystem routes.\n// \t\tif (typeof mod.serverPaths === \"function\") {\n// \t\t\tconst descriptSrvPaths: types.DescriptiveServerPaths = await mod.serverPaths(descriptSrvProps)\n//\n// \t\t\t// Generate a component router:\n// \t\t\tconst compRouter: types.ServerRouter = {}\n// \t\t\tfor (const { path, props } of descriptSrvPaths) {\n// \t\t\t\tcompRouter[path] = {\n// \t\t\t\t\troute,\n// \t\t\t\t\tprops: {\n// \t\t\t\t\t\tpath,\n// \t\t\t\t\t\t...props,\n// \t\t\t\t\t},\n// \t\t\t\t}\n// \t\t\t}\n//\n// \t\t\tfor (const [path, { props }] of Object.entries(compRouter)) {\n// \t\t\t\t// Merge the component router to the app router:\n// \t\t\t\t//\n// \t\t\t\t// TODO: Warn here for repeat paths.\n// \t\t\t\trouter[path] = { route, props }\n//\n// \t\t\t\t// Create a renderPayload for exportPage:\n// \t\t\t\tconst outputPath = p.join(runtime.directoryConfiguration.exportDir, pathToHTML(path))\n// \t\t\t\tconst render: RenderPayload = {\n// \t\t\t\t\toutputPath,\n// \t\t\t\t\tpath,\n// \t\t\t\t\tmodule: mod,\n// \t\t\t\t\tprops,\n// \t\t\t\t}\n// \t\t\t\tawait exportPage(runtime, render)\n// \t\t\t}\n// \t\t\tcontinue\n// \t\t}\n//\n// \t\t// Merge the route to the app router:\n// \t\t//\n// \t\t// TODO: Warn here for repeat paths.\n// \t\tconst path = route.path\n// \t\trouter[path] = { route, props: descriptSrvProps }\n//\n// \t\t// Create a renderPayload for exportPage:\n// \t\tconst outputPath = p.join(runtime.directoryConfiguration.exportDir, pathToHTML(path))\n// \t\tconst render: RenderPayload = {\n// \t\t\toutputPath,\n// \t\t\tpath,\n// \t\t\tmodule: mod,\n// \t\t\tprops: descriptSrvProps,\n// \t\t}\n// \t\tawait exportPage(runtime, render)\n// \t}\n//\n// \treturn router\n// }\n//\n// // renderAppSource renders the App source code (before esbuild).\n// //\n// // TODO: Write tests (pure function).\n// export async function renderAppSource(router: types.ServerRouter): Promise<string> {\n// \t// Get the shared components:\n// \tconst sharedComps = [...new Set(Object.keys(router).map(keys => router[keys]!.route.component))]\n//\n// \t// Create a shared server router based on shared component keys:\n// \tconst sharedRouter: types.ServerRouter = {}\n// \tfor (const [, meta] of Object.entries(router)) {\n// \t\tconst comp = meta.route.component\n// \t\tif (sharedComps.includes(comp) && sharedRouter[comp] === undefined) {\n// \t\t\tsharedRouter[comp] = meta\n// \t\t}\n// \t}\n//\n// \treturn `import React from \"react\"\n// import ReactDOM from \"react-dom\"\n// import { Route, Router } from \"../router\"\n// // Shared components\n// ${Object.entries(sharedRouter)\n// \t.map(([, { route }]) => `import ${route.component} from \"../${route.inputPath}\"`)\n// \t.join(\"\\n\")}\n// import router from \"./router.json\"\n// export default function App() {\n// \treturn (\n// \t\t<Router>\n// ${\n// \tObject.entries(router)\n// \t\t.map(\n// \t\t\t([path, meta]) => `\n// \t\t\t<Route path=\"${path}\">\n// \t\t\t\t<${meta.route.component} {\n// \t\t\t\t\t...router[\"${path}\"].props\n// \t\t\t\t} />\n// \t\t\t</Route>`,\n// \t\t)\n// \t\t.join(\"\\n\") + \"\\n\"\n// }\n// \t\t</Router>\n// \t)\n// }\n// ${\n// \tJSON.parse(process.env.STRICT_MODE || \"true\")\n// \t\t? `ReactDOM.${JSON.parse(process.env.RENDER || \"false\") ? \"render\" : \"hydrate\"}(\n// \t<React.StrictMode>\n// \t\t<App />\n// \t</React.StrictMode>,\n// \tdocument.getElementById(\"root\"),\n// )`\n// \t\t: `ReactDOM.${JSON.parse(process.env.RENDER || \"false\") ? \"render\" : \"hydrate\"}(\n// \t<App />,\n// \tdocument.getElementById(\"root\"),\n// )`\n// }\n// ` // EOF\n// }\n\nconst export_: types.export_ = async runtime => {\n\tawait runServerGuards(runtime.dir)\n\n\t// // Add server guards here.\n\t// if (cmd!.type === \"dev\" || cmd!.type === \"export\") {\n\t// \truntime.router = await createRouter(DIR_CONFIGURATION)\n\t// }\n\t// const router = await exportPagesAndCreateRouter(runtime)\n\t//\n\t// // Cache router for --cached:\n\t// const dst = p.join(runtime.directoryConfiguration.cacheDir, \"router.json\")\n\t// const data = JSON.stringify(router, null, \"\\t\") + \"\\n\" // EOF\n\t// await fs.promises.writeFile(dst, data)\n\t//\n\t// const appSource = await renderAppSource(router)\n\t// const appSourcePath = p.join(runtime.directoryConfiguration.cacheDir, \"app.js\")\n\t// await fs.promises.writeFile(appSourcePath, appSource)\n\t//\n\t// // Generate paths for esbuild:\n\t// const entryPoints = [appSourcePath]\n\t// const outfile = entryPoints[0]!.replace(\n\t// \tnew RegExp(\"^\" + runtime.directoryConfiguration.cacheDir.replace(\"/\", \"\\\\/\")),\n\t// \truntime.directoryConfiguration.exportDir,\n\t// )\n\t//\n\t// await esbuild.build({\n\t// \tbundle: true,\n\t// \tdefine: {\n\t// \t\t__DEV__: process.env.__DEV__!,\n\t// \t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV),\n\t// \t},\n\t// \tentryPoints,\n\t// \tformat: \"iife\", // DOM\n\t// \tinject: [\"scripts/react-shim.js\"],\n\t// \tloader: { \".js\": \"jsx\" },\n\t// \tlogLevel: \"silent\", // TODO\n\t// \tminify: true,\n\t// \toutfile,\n\t// \t// TODO: We should probably only need to resolve plugins once.\n\t// \t// plugins: [...configs.retro.plugins],\n\t// })\n\t// // TODO: Handle warnings, error, and hints.\n}\n\nexport default export_\n\n// ;(async () => {\n// \ttry {\n// \t\tawait run(require(\"../__cache__/runtime.json\"))\n// \t} catch (error) {\n// \t\tconsole.error(error.stack)\n// \t}\n// })()\n", "import * as esbuild from \"esbuild\"\nimport * as http from \"http\"\nimport * as log from \"../../lib/log\"\nimport * as p from \"path\"\nimport * as term from \"../../lib/term\"\nimport * as types from \"../types\"\nimport * as utils from \"../utils\"\n\n// spaify converts a URL for SPA-mode.\nfunction spaify(_: string): string {\n\treturn \"/\"\n}\n\n// ssgify converts a URL for SSG-mode.\nfunction ssgify(url: string): string {\n\tif (url.endsWith(\"/\")) return url + \"index.html\"\n\tif (p.extname(url) === \"\") return url + \".html\"\n\treturn url\n}\n\n// This implementation is roughly based on:\n//\n// - https://esbuild.github.io/api/#customizing-server-behavior\n// - https://github.com/evanw/esbuild/issues/858#issuecomment-782814216\n//\nconst serve: types.serve = async runtime => {\n\tsetTimeout(() => {\n\t\tif (utils.getWillEagerlyTerminate()) return\n\t\tutils.clearScreen()\n\t\tlog.info(`http://localhost:${runtime.cmd.port}`)\n\t}, 10)\n\n\t// prettier-ignore\n\tconst result = await esbuild.serve({\n\t\tservedir: runtime.dir.exportDir,\n\t\tonRequest: (args: esbuild.ServeOnRequestArgs) => {\n\t\t\tlet descriptMs = args.timeInMS + \"ms\"\n\t\t\tif (args.status >= 200 && args.status < 300 && args.timeInMS === 0) {\n\t\t\t\tdescriptMs += \" - cached\"\n\t\t\t}\n\t\t\tconsole.log(`${\" \".repeat(2)}${term.bold(\"\u2192\")} ${args.method} ${args.path} ${args.status >= 200 && args.status < 300 ? term.green(args.status) : term.red(args.status)} (${descriptMs})`)\n\t\t},\n\t}, {})\n\n\tlet transformURL = ssgify\n\tif (runtime.cmd.mode === \"spa\") {\n\t\ttransformURL = spaify\n\t}\n\n\t// The proxy server.\n\tconst proxySrv = http.createServer((req, res) => {\n\t\t// The proxy request.\n\t\tconst proxyReq = http.request({ ...req, path: transformURL(req.url!), port: result.port }, proxyRes => {\n\t\t\t// The proxy response.\n\t\t\tif (proxyRes.statusCode === 404) {\n\t\t\t\tres.writeHead(200, { \"Content-Type\": \"text/plain\" })\n\t\t\t\tres.end(\"404 page not found\")\n\t\t\t} else {\n\t\t\t\tres.writeHead(proxyRes.statusCode!, proxyRes.headers)\n\t\t\t\tproxyRes.pipe(res, { end: true })\n\t\t\t}\n\t\t})\n\t\treq.pipe(proxyReq, { end: true })\n\t})\n\tproxySrv.listen(runtime.cmd.port)\n}\n\nexport default serve\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAO,IAAM,QAAQ;AACd,IAAM,OAAO,IAAI,SAA4B,SAAY,KAAK,KAAK,OAAO;AAC1E,IAAM,OAAO,IAAI,SAA4B,SAAY,KAAK,KAAK,OAAO;AAC1E,IAAM,YAAY,IAAI,SAA4B,SAAY,KAAK,KAAK,OAAO;AAE/E,IAAM,MAAM,IAAI,SAA4B,UAAa,KAAK,KAAK,OAAO;AAC1E,IAAM,QAAQ,IAAI,SAA4B,UAAa,KAAK,KAAK,OAAO;AAQ5E,IAAM,UAAU,IAAI,SAA4B,UAAa,KAAK,KAAK,OAAO;AAC9E,IAAM,YAAY,IAAI,SAA4B,UAAa,KAAK,KAAK,OAAO;;;ACZvF,uBAAuB;AACtB,SAAO,IAAI,MAAM,MAAM,IAAI,CAAC,MAAM;AACjC,QAAI,MAAM;AAAG,aAAO;AACpB,QAAI,SAAS;AAAI,aAAO;AACxB,WAAO,IAAI,OAAO,KAAK,KAAK,QAAQ,KAAM;AAAA,KACxC,KAAK;AAAA;AAGF,iBAAiB;AACvB,QAAM,UAAU,cAAc,KAAK,KAAK;AAExC,UAAQ,IAAI,GAAG,AAAK,KAAK,CAAC,QAAQ,OAAO,GAAG,QAAQ,KAAK,MAAM,IAAI,KAAK;AAAA;AAAA,EAEvE,IAAI,OAAO,KAAK,AAAK,KAAK,QAAQ,AAAK,UAAU,UAAU,AAAK,KAAK;AAAA;AAAA;AAKhE,eAAe;AACrB,QAAM,UAAU,cAAc,OAAO,WAAU,WAAW,OAAM,UAAU;AAE1E,QAAM,eAAe,QAAQ,IAAI,mBAAmB;AACpD,MAAI,CAAC;AACJ,YAAQ,MAAM,GAAG,AAAK,KAAK,CAAC,QAAQ,OAAO,GAAG,QAAQ,KAAK,MAAM,IAAI,KAAK;AAAA;AAAA,EAE1E,IAAI,OAAO,KAAK,AAAK,KAAK,QAAQ,AAAK,QAAQ,aAAa,AAAK,KAAK;AAAA;AAAA;AAGtE,YAAQ,MAAM,GAAG,AAAK,KAAK,CAAC,QAAQ,OAAO,GAAG,QAAQ,KAAK,MAAM,IAAI,KAAK;AAAA;AAAA,EAE1E,IAAI,OAAO,KAAK,AAAK,KAAK,QAAQ,AAAK,QAAQ,aAAa,AAAK,KAAK;AAAA;AAEtE,YAAQ,MAAM,CAAE;AAAA;AAEjB,UAAQ,KAAK;AAAA;;;ACrCd,sBAAqB;AAErB,IAAI,uBAAuB;AAGpB;AACN,SAAO;AAAA;AAID,iCAAiC;AACvC,yBAAuB;AAAA;AAMjB;AACN,QAAM,cAAc,KAAK,OAAO,QAAQ,OAAO;AAC/C,UAAQ,IAAI;AACZ,0BAAS,SAAS,QAAQ,QAAQ,GAAG;AACrC,0BAAS,gBAAgB,QAAQ;AAAA;;;ACrBlC,SAAoB;AAEpB,QAAmB;AAInB,+BAA8C;AAC7C,QAAM,OAAO,OAAO,QAAQ,KAAK,IAAI,CAAC,CAAC,GAAG,OAAO;AAGjD,aAAW,QAAQ;AAClB;AACC,YAAM,AAAG,YAAS,KAAK;AAAA,aACf;AACR,MAAG,YAAS,MAAM,MAAM,CAAE,WAAW;AAAA;AAAA;AAKvC,QAAM,OAAO,AAAE,OAAK,IAAI,WAAW;AACnC;AACC,UAAM,OAAO,MAAM,AAAG,YAAS,SAAS;AACxC,UAAM,OAAO,KAAK;AAClB,QAAI,CAAC,KAAK,SAAS;AAClB,MAAI,MAAM,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAWH,CAAC,KAAK,SAAS;AACzB,MAAI,MAAM,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,WAYN;AACR,UAAM,AAAG,YAAS,UACjB,MACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC0KH,IAAM,UAAyB,OAAM;AACpC,QAAM,gBAAgB,QAAQ;AAAA;AA2C/B,IAAO,iBAAQ;;;ACzQf,cAAyB;AACzB,WAAsB;AAEtB,SAAmB;AAMnB,gBAAgB;AACf,SAAO;AAAA;AAIR,gBAAgB;AACf,MAAI,IAAI,SAAS;AAAM,WAAO,MAAM;AACpC,MAAI,AAAE,WAAQ,SAAS;AAAI,WAAO,MAAM;AACxC,SAAO;AAAA;AAQR,IAAM,SAAqB,OAAM;AAChC,aAAW;AACV,QAAI,AAAM;AAA2B;AACrC,IAAM;AACN,IAAI,KAAK,oBAAoB,QAAQ,IAAI;AAAA,KACvC;AAGH,QAAM,SAAS,MAAM,AAAQ,cAAM;AAAA,IAClC,UAAU,QAAQ,IAAI;AAAA,IACtB,WAAW,CAAC;AACX,UAAI,aAAa,KAAK,WAAW;AACjC,UAAI,KAAK,UAAU,OAAO,KAAK,SAAS,OAAO,KAAK,aAAa;AAChE,sBAAc;AAAA;AAEf,cAAQ,IAAI,GAAG,IAAI,OAAO,KAAK,AAAK,KAAK,aAAQ,KAAK,UAAU,KAAK,QAAQ,KAAK,UAAU,OAAO,KAAK,SAAS,MAAM,AAAK,MAAM,KAAK,UAAU,AAAK,IAAI,KAAK,YAAY;AAAA;AAAA,KAE1K;AAEH,MAAI,eAAe;AACnB,MAAI,QAAQ,IAAI,SAAS;AACxB,mBAAe;AAAA;AAIhB,QAAM,WAAW,AAAK,kBAAa,CAAC,KAAK;AAExC,UAAM,WAAW,AAAK,aAAQ,IAAK,KAAK,MAAM,aAAa,IAAI,MAAO,MAAM,OAAO,OAAQ;AAE1F,UAAI,SAAS,eAAe;AAC3B,YAAI,UAAU,KAAK,CAAE,gBAAgB;AACrC,YAAI,IAAI;AAAA;AAER,YAAI,UAAU,SAAS,YAAa,SAAS;AAC7C,iBAAS,KAAK,KAAK,CAAE,KAAK;AAAA;AAAA;AAG5B,QAAI,KAAK,UAAU,CAAE,KAAK;AAAA;AAE3B,WAAS,OAAO,QAAQ,IAAI;AAAA;AAG7B,IAAO,gBAAQ;;;AN1DR,IAAM,OAAO;AAAA;AAAA;AAAA;AAAA,EAIlB;AAGK,IAAM,QAAQ,GAAG,AAAK,KAAK,CAAC,QAAQ,OAAO,GAAG,QAAQ,KAAK,MAAM,IAAI,KAAK;AAAA;AAAA,IAE7E,AAAK,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMV,AAAK,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQV,AAAK,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOV,AAAK,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOV,AAAK,KAAK;AAAA;AAAA,MAER,AAAK,UAAU;AAAA;AAMrB,iCAAiC;AAChC,QAAM,MAAwB;AAAA,IAC7B,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,WAAW;AAAA,IACX,MAAM;AAAA;AAEP,MAAI,SAAS;AACb,aAAW,OAAO;AACjB,QAAI,IAAI,WAAW;AAClB,UAAI,QAAQ;AACX,YAAI,SAAS;AAAA,iBACH,QAAQ,mBAAmB,QAAQ;AAC7C,YAAI,SAAS,KAAK,MAAM,IAAI,MAAM,YAAY;AAAA;AAE9C,iBAAS;AACT;AAAA;AAAA,eAES,IAAI,WAAW;AACzB,UAAI,QAAQ;AACX,YAAI,YAAY;AAAA,iBACN,QAAQ,sBAAsB,QAAQ;AAChD,YAAI,YAAY,KAAK,MAAM,IAAI,MAAM,eAAe;AAAA;AAEpD,iBAAS;AACT;AAAA;AAAA,eAES,IAAI,WAAW;AACzB,UAAI,eAAe,KAAK;AACvB,YAAI,OAAO,KAAK,MAAM,IAAI,MAAM,UAAU;AAAA;AAE1C,iBAAS;AACT;AAAA;AAAA;AAGD,eAAS;AAAA;AAAA;AAGX,MAAI,WAAW;AACd,IAAI,MAAM,gBAAgB;AAAA;AAE3B,MAAI,IAAI,OAAO,OAAO,IAAI,QAAQ;AACjC,IAAI,MAAM;AAAA;AAEX,SAAO;AAAA;AAMR,oCAAoC;AACnC,QAAM,MAA2B;AAAA,IAChC,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,WAAW;AAAA;AAEZ,MAAI,SAAS;AACb,aAAW,OAAO;AACjB,QAAI,IAAI,WAAW;AAClB,UAAI,QAAQ;AACX,YAAI,SAAS;AAAA,iBACH,QAAQ,mBAAmB,QAAQ;AAC7C,YAAI,SAAS,KAAK,MAAM,IAAI,MAAM,YAAY;AAAA;AAE9C,iBAAS;AACT;AAAA;AAAA,eAES,IAAI,WAAW;AACzB,UAAI,QAAQ;AACX,YAAI,YAAY;AAAA,iBACN,QAAQ,sBAAsB,QAAQ;AAChD,YAAI,YAAY,KAAK,MAAM,IAAI,MAAM,eAAe;AAAA;AAEpD,iBAAS;AACT;AAAA;AAAA;AAGD,eAAS;AAAA;AAAA;AAGX,MAAI,WAAW;AACd,IAAI,MAAM,gBAAgB;AAAA;AAE3B,SAAO;AAAA;AAMR,mCAAmC;AAClC,QAAM,MAA0B;AAAA,IAC/B,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA;AAEP,MAAI,SAAS;AACb,aAAW,OAAO;AACjB,QAAI,IAAI,WAAW;AAClB,UAAI,QAAQ;AACX,YAAI,OAAO;AAAA,iBACD,QAAQ;AAClB,YAAI,OAAO;AAAA;AAEX,iBAAS;AACT;AAAA;AAAA,eAES,IAAI,WAAW;AACzB,UAAI,eAAe,KAAK;AACvB,YAAI,OAAO,KAAK,MAAM,IAAI,MAAM,UAAU;AAAA;AAE1C,iBAAS;AACT;AAAA;AAAA;AAGD,eAAS;AAAA;AAAA;AAGX,MAAI,WAAW;AACd,IAAI,MAAM,gBAAgB;AAAA;AAE3B,MAAI,IAAI,OAAO,OAAO,IAAI,QAAQ;AACjC,IAAI,MAAM;AAAA;AAEX,SAAO;AAAA;AAIR,IAAM,oBAAoB;AAAA,EACxB,WAAa,QAAQ,IAAI,cAAc;AAAA,EACvC,aAAa,QAAQ,IAAI,aAAc;AAAA,EACvC,UAAa,QAAQ,IAAI,aAAc;AAAA,EACvC,WAAa,QAAQ,IAAI,cAAc;AAAA;AAGzC;AACC,QAAM,OAAO,QAAQ,UAAU,SAAS,QAAQ,KAAK,MAAM,KAAK,QAAQ;AAGxE,MAAI,KAAK,WAAW;AACnB,YAAQ,IAAI;AACZ,YAAQ,KAAK;AAAA;AAGd,MAAI;AACJ,QAAM,MAAM,KAAK;AACjB,MAAI,QAAQ,aAAa,QAAQ,eAAe,QAAQ;AACvD,YAAQ,IAAI,QAAQ,IAAI,oBAAoB;AAC5C,YAAQ,KAAK;AAAA,aACH,QAAQ,WAAW,QAAQ,aAAa,QAAQ,UAAU,QAAQ;AAC5E,YAAQ,IAAI;AACZ,YAAQ,KAAK;AAAA,aACH,QAAQ;AAClB,YAAQ,IAAI,aAAa;AACzB,YAAQ,IAAI,cAAc;AAC1B,UAAM,qBAAqB,GAAG,KAAK,MAAM;AAAA,aAC/B,QAAQ;AAClB,YAAQ,IAAI,aAAa;AACzB,YAAQ,IAAI,cAAc;AAC1B,UAAM,wBAAwB,GAAG,KAAK,MAAM;AAAA,aAClC,QAAQ;AAClB,YAAQ,IAAI,aAAa;AACzB,YAAQ,IAAI,cAAc;AAC1B,UAAM,uBAAuB,GAAG,KAAK,MAAM;AAAA;AAE3C,IAAI,MAAM,oBAAoB;AAAA;AAAA,EAE9B;AAAA;AAAA;AAAA;AAKD,QAAM,UAAyB;AAAA,IAC9B;AAAA,IACA,KAAK;AAAA,IACL,QAAQ;AAAA;AAGT,UAAQ,IAAK;AAAA,SACP;AAEJ;AAAA,SACI;AACJ,YAAM,KAAK;AACX,YAAM,eAAQ;AACd;AAAA,SACI;AACJ,YAAM,KAAK;AACX,YAAM,cAAM;AACZ;AAAA;AAAA;AAIH,QAAQ,GAAG,qBAAqB;AAC/B,EAAM,wBAAwB;AAC9B,UAAQ,IAAI,iBAAiB;AAC7B,MAAI,UAAU,sBAAsB,IAAI;AACxC,EAAI,MAAM;AAAA;AAGX;",
  "names": []
}
