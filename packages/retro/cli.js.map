{
  "version": 3,
  "sources": ["cli.ts", "../lib/term.ts", "../lib/log.ts", "utils.ts", "serve.ts"],
  "sourcesContent": ["import * as log from \"../lib/log\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\nimport serve from \"./serve\"\n\nexport const cmds = `\nretro dev     Start the dev server\nretro export  Export the production-ready build (SSG)\nretro serve   Serve the production-ready build\n`.trim()\n\nexport const usage =\n\t`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n  ${term.bold(\"Usage:\")}\n\n    retro dev     Start the dev server\n    retro export  Export the production-ready build (SSG)\n    retro serve   Serve the production-ready build\n\n  ${term.bold(\"retro dev\")}\n\n    Start the dev server\n\n      --cached=...         Use cached resources (default false)\n      --source-map=...     Add source maps (default true)\n      --port=<number>=...  Port number (default 8000)\n\n  ${term.bold(\"retro export\")}\n\n    Export the production-ready build (SSG)\n\n      --cached=...         Use cached resources (default false)\n      --source-map=...     Add source maps (default true)\n\n  ${term.bold(\"retro serve\")}\n\n    Serve the production-ready build\n\n      --port=...           Port number (default 8000)\n\n  ${term.bold(\"Repository:\")}\n\n    ` +\n\tterm.underline(\"https://github.com/zaydek/retro\") +\n\t`\n`\n\n// parseDevCommandArgs parses 'retro dev [flags]'.\n// TODO: Write tests.\nfunction parseDevCommandArgs(...args: string[]): types.DevCommand {\n\tconst cmd: types.DevCommand = {\n\t\ttype: \"dev\",\n\t\tcached: false,\n\t\tsourcemap: true,\n\t\tport: 8000,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\tif (arg === \"--cached\") {\n\t\t\t\tcmd.cached = true\n\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\tcmd.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--cached\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\tcmd.sourcemap = true\n\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\tcmd.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--sourcemap\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--port\")) {\n\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\tcmd.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--port\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\tif (cmd.port < 1e3 || cmd.port >= 1e4) {\n\t\tlog.error(\"'--port' must be between 1000-9999.\")\n\t}\n\treturn cmd\n}\n\n// parseExportCommandArgs parses 'retro export [flags]'.\n// TODO: Write tests.\nfunction parseExportCommandArgs(...args: string[]): types.ExportCommand {\n\tconst cmd: types.ExportCommand = {\n\t\ttype: \"export\",\n\t\tcached: false,\n\t\tsourcemap: true,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\tif (arg === \"--cached\") {\n\t\t\t\tcmd.cached = true\n\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\tcmd.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--cached\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\tcmd.sourcemap = true\n\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\tcmd.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--sourcemap\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\treturn cmd\n}\n\n// parseServeCommandArgs parses 'retro serve [flags]'.\n// TODO: Write tests.\nfunction parseServeCommandArgs(...args: string[]): types.ServeCommand {\n\tconst cmd: types.ServeCommand = {\n\t\ttype: \"serve\",\n\t\tport: 8000,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--port\")) {\n\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\tcmd.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--port\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\tif (cmd.port < 1e3 || cmd.port >= 1e4) {\n\t\tlog.error(\"'--port' must be between 1000-9999.\")\n\t}\n\treturn cmd\n}\n\n// prettier-ignore\nconst DIRS = {\n\tpublicDir:   process.env.PUBLIC_DIR || \"public\",\n\tsrcPagesDir: process.env.PAGES_DIR  || \"src/pages\",\n\tcacheDir:    process.env.CACHE_DIR  || \"__cache__\",\n\texportDir:   process.env.EXPORT_DIR || \"__export__\",\n}\n\nasync function run(): Promise<void> {\n\tconst args = process.argv0 === \"node\" ? process.argv.slice(1) : process.argv\n\n\t// Cover [\"retro\"] case:\n\tif (args.length === 1) {\n\t\tconsole.log(usage)\n\t\tprocess.exit(0)\n\t}\n\n\tlet cmd: types.Command\n\tconst arg = args[1]\n\tif (arg === \"version\" || arg === \"--version\" || arg === \"--v\") {\n\t\tconsole.log(process.env[\"RETRO_VERSION\"] || \"TODO\")\n\t\tprocess.exit(0)\n\t} else if (arg === \"usage\" || arg === \"--usage\" || arg === \"help\" || arg === \"--help\") {\n\t\tconsole.log(usage)\n\t\tprocess.exit(0)\n\t} else if (arg === \"dev\") {\n\t\tprocess.env[\"__DEV__\"] = \"true\"\n\t\tprocess.env[\"NODE_ENV\"] = \"development\"\n\t\tcmd = parseDevCommandArgs(...args.slice(2))\n\t} else if (arg === \"export\") {\n\t\tprocess.env[\"__DEV__\"] = \"false\"\n\t\tprocess.env[\"NODE_ENV\"] = \"production\"\n\t\tcmd = parseExportCommandArgs(...args.slice(2))\n\t} else if (arg === \"serve\") {\n\t\tprocess.env[\"__DEV__\"] = \"false\"\n\t\tprocess.env[\"NODE_ENV\"] = \"production\"\n\t\tcmd = parseServeCommandArgs(...args.slice(2))\n\t} else {\n\t\t// TODO: log.error should automatically space-indent so we don\u2019t have to at\n\t\t// every call site.\n\t\t// prettier-ignore\n\t\tlog.error(new Error(`No such command '${arg}'. Use one of these commands:\n\n${cmds.split(\"\\n\").map(each => `${\" \".repeat(2)}- ${each}`).join(\"\\n\")}\n\n  Or use 'retro usage' for usage.`))\n\t}\n\n\tconst runtime: types.Runtime<types.Command> = {\n\t\tcmd: cmd!,\n\t\tdirs: DIRS,\n\t}\n\n\tswitch (cmd!.type) {\n\t\tcase \"dev\":\n\t\t\t// await serve(runtime as types.Runtime<types.DevCommand>)\n\t\t\tbreak\n\t\tcase \"export\":\n\t\t\t// await serve(runtime as types.Runtime<types.ExportCommand>)\n\t\t\tbreak\n\t\tcase \"serve\":\n\t\t\tawait serve(runtime as types.Runtime<types.ServeCommand>)\n\t\t\tbreak\n\t}\n}\n\nprocess.on(\"uncaughtException\", err => {\n\tutils.setWillEagerlyTerminate(true)\n\n\t// console.log({ err })\n\n\t// Force the stack trace on:\n\tprocess.env[\"STACK_TRACE\"] = \"true\"\n\terr.message = `UncaughtException: ${err.message}.`\n\tlog.error(err)\n})\n\nrun()\n", "export const none          = (...args: unknown[]): string => args.join(\" \")\nexport const bold          = (...args: unknown[]): string => `\\x1b[0;1m${args.join(\" \")}\\x1b[0m`\nexport const gray          = (...args: unknown[]): string => `\\x1b[0;2m${args.join(\" \")}\\x1b[0m`\nexport const underline     = (...args: unknown[]): string => `\\x1b[0;4m${args.join(\" \")}\\x1b[0m`\nexport const black         = (...args: unknown[]): string => `\\x1b[0;30m${args.join(\" \")}\\x1b[0m`\nexport const red           = (...args: unknown[]): string => `\\x1b[0;31m${args.join(\" \")}\\x1b[0m`\nexport const green         = (...args: unknown[]): string => `\\x1b[0;32m${args.join(\" \")}\\x1b[0m`\nexport const yellow        = (...args: unknown[]): string => `\\x1b[0;33m${args.join(\" \")}\\x1b[0m`\nexport const purple        = (...args: unknown[]): string => `\\x1b[0;34m${args.join(\" \")}\\x1b[0m`\nexport const magenta       = (...args: unknown[]): string => `\\x1b[0;35m${args.join(\" \")}\\x1b[0m`\nexport const teal          = (...args: unknown[]): string => `\\x1b[0;36m${args.join(\" \")}\\x1b[0m`\nexport const white         = (...args: unknown[]): string => `\\x1b[0;37m${args.join(\" \")}\\x1b[0m`\nexport const boldUnderline = (...args: unknown[]): string => `\\x1b[1;4m${args.join(\" \")}\\x1b[0m`\nexport const boldBlack     = (...args: unknown[]): string => `\\x1b[1;30m${args.join(\" \")}\\x1b[0m`\nexport const boldRed       = (...args: unknown[]): string => `\\x1b[1;31m${args.join(\" \")}\\x1b[0m`\nexport const boldGreen     = (...args: unknown[]): string => `\\x1b[1;32m${args.join(\" \")}\\x1b[0m`\nexport const boldYellow    = (...args: unknown[]): string => `\\x1b[1;33m${args.join(\" \")}\\x1b[0m`\nexport const boldPurple    = (...args: unknown[]): string => `\\x1b[1;34m${args.join(\" \")}\\x1b[0m`\nexport const boldMagenta   = (...args: unknown[]): string => `\\x1b[1;35m${args.join(\" \")}\\x1b[0m`\nexport const boldTeal      = (...args: unknown[]): string => `\\x1b[1;36m${args.join(\" \")}\\x1b[0m`\nexport const boldWhite     = (...args: unknown[]): string => `\\x1b[1;37m${args.join(\" \")}\\x1b[0m`\n", "import * as term from \"./term\"\n\nexport function error(error: string | Error): void {\n\tif (typeof error === \"string\") error = new Error(error)\n\n\tconst traceEnabled = process.env[\"STACK_TRACE\"] === \"true\"\n\tif (!traceEnabled) {\n\t\tconsole.error(`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n  ${term.bold(\">\")} ${term.boldRed(\"error:\")} ${term.bold(error.message)}\n`)\n\t} else {\n\t\tconsole.error(`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n  ${term.bold(\">\")} ${term.boldRed(\"error:\")} ${term.bold(error.message)}\n`)\n\t\tconsole.error({ error })\n\t}\n\tprocess.exit(0)\n}\n", "import readline from \"readline\"\n\nlet willEagerlyTerminate = false\n\n// getWillEagerlyTerminate gets whether the runtime will eagerly terminate.\nexport function getWillEagerlyTerminate(): boolean {\n\treturn willEagerlyTerminate\n}\n\n// setWillEagerlyTerminate sets whether the runtime will eagerly terminate.\nexport function setWillEagerlyTerminate(t: boolean): void {\n\twillEagerlyTerminate = t\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// https://gist.github.com/timneutkens/f2933558b8739bbf09104fb27c5c9664\nexport function clearScreen(): void {\n\tconst emptyScreen = \"\\n\".repeat(process.stdout.rows)\n\tconsole.log(emptyScreen)\n\treadline.cursorTo(process.stdout, 0, 0)\n\treadline.clearScreenDown(process.stdout)\n}\n", "import * as esbuild from \"esbuild\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\n// This implementation is loosely based on https://stackoverflow.com/a/44188852.\n// TODO: Use the esbuild serve command?\nconst serve: types.serve = async runtime => {\n\tsetTimeout(() => {\n\t\tif (utils.getWillEagerlyTerminate()) return\n\t\tutils.clearScreen()\n\t\tconsole.log(`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n  ${term.bold(\">\")} ${term.boldGreen(\"ok:\")} ${term.bold(\n\t\t\t`Serving your app on port ${runtime.cmd.port}; ${term.boldUnderline(\n\t\t\t\t`http://localhost:${runtime.cmd.port}`,\n\t\t\t)}${term.bold(\".\")}`,\n\t\t)}\n\n  ${term.bold(`When you\u2019re ready to stop the server, press Ctrl-C.`)}\n\t`)\n\t}, 10)\n\n\tawait esbuild.serve(\n\t\t{\n\t\t\tport: runtime.cmd.port,\n\t\t\tservedir: runtime.dirs.exportDir,\n\t\t\t// onRequest: (_: esbuild.ServeOnRequestArgs) => {},\n\t\t},\n\t\t{},\n\t)\n\n\t// const server = http.createServer(\n\t// \tasync (req, res): Promise<void> => {\n\t// \t\tif (req.url === \"/favicon.ico\") {\n\t// \t\t\tres.writeHead(204)\n\t// \t\t\treturn\n\t// \t\t}\n\t//\n\t// \t\t// Convert the browser path to a filesystem path:\n\t// \t\treq.url = convertToFilesystemPath(req.url!)\n\t//\n\t// \t\tlet bytes: Buffer\n\t// \t\ttry {\n\t// \t\t\tconst path = p.join(process.cwd(), req.url)\n\t// \t\t\tbytes = await fs.promises.readFile(path)\n\t// \t\t} catch (err) {\n\t// \t\t\tif (err.code === constants.ENOENT) {\n\t// \t\t\t\tres.writeHead(404)\n\t// \t\t\t\tres.end(http.STATUS_CODES[404])\n\t// \t\t\t\t// ...\n\t// \t\t\t\treturn\n\t// \t\t\t} else {\n\t// \t\t\t\tres.writeHead(500)\n\t// \t\t\t\tres.end(http.STATUS_CODES[500])\n\t// \t\t\t\t// ...\n\t// \t\t\t\treturn\n\t// \t\t\t}\n\t// \t\t}\n\t// \t\t// Done:\n\t// \t\tres.writeHead(200)\n\t// \t\t// ...\n\t// \t\tres.end(bytes)\n\t// \t},\n\t// )\n\t//\n\t// setTimeout(() => {\n\t// \t// if (didError()) return\n\t// \tutils.clearScreen()\n\t// \tconsole.log(`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\t//\n\t// ${term.bold(\">\")} ${term.boldGreen(\"ok:\")} ${term.bold(\n\t// \t\t`Serving your app on port ${PORT} (SSG); ${term.boldUnderline(`http://localhost:${PORT}`)}${term.bold(\".\")}`,\n\t// \t)}\n\t//\n\t// ${term.bold(`When you\u2019re ready to stop the server, press Ctrl-C.`)}\n\t// )\n\t// }, 10)\n\t// server.listen(PORT)\n}\n\n// ;(() => {\n// \ttry {\n// \t\tserve()\n// \t} catch (err) {\n// \t\terrored = true\n// \t\terr.message = \"An unexpected error occurred while trying to serve your web app; \" + err.message\n// \t\tlog.error(err)\n// \t}\n// })()\n\nexport default serve\n"],
  "mappings": "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",
  "names": []
}
