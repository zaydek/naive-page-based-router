{
  "version": 3,
  "sources": ["cli.ts", "../lib/term.ts", "../lib/log.ts", "utils.ts", "createRouter.ts", "export_.ts", "serve.ts"],
  "sourcesContent": ["import * as log from \"../lib/log\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\nimport export_ from \"./export_\"\nimport serve from \"./serve\"\n\nexport const cmds = `\nretro dev     Start the dev server\nretro export  Export the production-ready build (SSG)\nretro serve   Serve the production-ready build\n`.trim()\n\nexport const usage = `${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n  ${term.bold(\"Usage:\")}\n\n    retro dev     Start the dev server\n    retro export  Export the production-ready build (SSG)\n    retro serve   Serve the production-ready build\n\n  ${term.bold(\"retro dev\")}\n\n    Start the dev server\n\n      --cached=...     Use cached resources (default false)\n      --sourcemap=...  Add source maps (default true)\n      --port=...       Port number (default 8000)\n\n  ${term.bold(\"retro export\")}\n\n    Export the production-ready build (SSG)\n\n      --cached=...     Use cached resources (default false)\n      --sourcemap=...  Add source maps (default true)\n\n  ${term.bold(\"retro serve\")}\n\n    Serve the production-ready build\n\n      --mode=...       Serve mode 'spa' or 'ssg' (default 'ssg')\n      --port=...       Port number (default 8000)\n\n  ${term.bold(\"Repository:\")}\n\n    ${term.underline(\"https://github.com/zaydek/retro\")}\n`\n\n// parseDevCommandArgs parses 'retro dev [flags]'.\n// TODO: Write tests.\nfunction parseDevCommandArgs(...args: string[]): types.DevCommand {\n\tconst cmd: types.DevCommand = {\n\t\ttype: \"dev\",\n\t\tcached: false,\n\t\tsourcemap: true,\n\t\tport: 8000,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\tif (arg === \"--cached\") {\n\t\t\t\tcmd.cached = true\n\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\tcmd.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--cached\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\tcmd.sourcemap = true\n\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\tcmd.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--sourcemap\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--port\")) {\n\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\tcmd.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--port\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\tif (cmd.port < 1e3 || cmd.port >= 1e4) {\n\t\tlog.error(\"'--port' must be between 1000-9999.\")\n\t}\n\treturn cmd\n}\n\n// parseExportCommandArgs parses 'retro export [flags]'.\n// TODO: Write tests.\nfunction parseExportCommandArgs(...args: string[]): types.ExportCommand {\n\tconst cmd: types.ExportCommand = {\n\t\ttype: \"export\",\n\t\tcached: false,\n\t\tsourcemap: true,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\tif (arg === \"--cached\") {\n\t\t\t\tcmd.cached = true\n\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\tcmd.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--cached\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\tcmd.sourcemap = true\n\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\tcmd.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--sourcemap\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\treturn cmd\n}\n\n// parseServeCommandArgs parses 'retro serve [flags]'.\n// TODO: Write tests.\nfunction parseServeCommandArgs(...args: string[]): types.ServeCommand {\n\tconst cmd: types.ServeCommand = {\n\t\ttype: \"serve\",\n\t\tmode: \"ssg\",\n\t\tport: 8000,\n\t}\n\tlet badCmd = \"\"\n\tfor (const arg of args) {\n\t\tif (arg.startsWith(\"--mode\")) {\n\t\t\tif (arg === \"--mode=spa\") {\n\t\t\t\tcmd.mode = \"spa\"\n\t\t\t} else if (arg === \"--mode=ssg\") {\n\t\t\t\tcmd.mode = \"ssg\"\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--mode\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else if (arg.startsWith(\"--port\")) {\n\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\tcmd.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t} else {\n\t\t\t\tbadCmd = \"--port\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\tbadCmd = arg\n\t\t}\n\t}\n\tif (badCmd !== \"\") {\n\t\tlog.error(`Bad command '${badCmd}'. You can use 'retro help' for help.`)\n\t}\n\tif (cmd.port < 1e3 || cmd.port >= 1e4) {\n\t\tlog.error(\"'--port' must be between 1000-9999.\")\n\t}\n\treturn cmd\n}\n\n// prettier-ignore\nconst DIRS = {\n\tpublicDir:   process.env.PUBLIC_DIR || \"public\",\n\tsrcPagesDir: process.env.PAGES_DIR  || \"src/pages\",\n\tcacheDir:    process.env.CACHE_DIR  || \"__cache__\",\n\texportDir:   process.env.EXPORT_DIR || \"__export__\",\n}\n\nasync function run(): Promise<void> {\n\tconst args = process.argv0 === \"node\" ? process.argv.slice(1) : process.argv\n\n\t// Cover [\"retro\"] case:\n\tif (args.length === 1) {\n\t\tconsole.log(usage)\n\t\tprocess.exit(0)\n\t}\n\n\tlet cmd: types.Command\n\tconst arg = args[1]\n\tif (arg === \"version\" || arg === \"--version\" || arg === \"--v\") {\n\t\tconsole.log(process.env[\"RETRO_VERSION\"] || \"TODO\")\n\t\tprocess.exit(0)\n\t} else if (arg === \"usage\" || arg === \"--usage\" || arg === \"help\" || arg === \"--help\") {\n\t\tconsole.log(usage)\n\t\tprocess.exit(0)\n\t} else if (arg === \"dev\") {\n\t\tprocess.env[\"__DEV__\"] = \"true\"\n\t\tprocess.env[\"NODE_ENV\"] = \"development\"\n\t\tcmd = parseDevCommandArgs(...args.slice(2))\n\t} else if (arg === \"export\") {\n\t\tprocess.env[\"__DEV__\"] = \"false\"\n\t\tprocess.env[\"NODE_ENV\"] = \"production\"\n\t\tcmd = parseExportCommandArgs(...args.slice(2))\n\t} else if (arg === \"serve\") {\n\t\tprocess.env[\"__DEV__\"] = \"false\"\n\t\tprocess.env[\"NODE_ENV\"] = \"production\"\n\t\tcmd = parseServeCommandArgs(...args.slice(2))\n\t} else {\n\t\tlog.error(`No such command '${arg}'. Use one of these commands:\n\n${cmds}\n\nOr use 'retro usage' for usage.`)\n\t}\n\n\tconst runtime: types.Runtime<types.Command> = {\n\t\tcmd: cmd!,\n\t\tdir: DIRS,\n\t}\n\n\tswitch (cmd!.type) {\n\t\tcase \"dev\":\n\t\t\t// await serve(runtime as types.Runtime<types.DevCommand>)\n\t\t\tbreak\n\t\tcase \"export\":\n\t\t\tconst r2 = runtime as types.Runtime<types.ExportCommand>\n\t\t\tawait export_(r2)\n\t\t\tbreak\n\t\tcase \"serve\":\n\t\t\tconst r3 = runtime as types.Runtime<types.ServeCommand>\n\t\t\tawait serve(r3)\n\t\t\tbreak\n\t}\n}\n\nprocess.on(\"uncaughtException\", err => {\n\tutils.setWillEagerlyTerminate(true)\n\n\t// Force the stack trace on:\n\tprocess.env[\"STACK_TRACE\"] = \"true\"\n\terr.message = `UncaughtException: ${err.message}.`\n\tlog.error(err)\n})\n\nrun()\n", "export const none          = (...args: unknown[]): string => args.join(\" \")\nexport const bold          = (...args: unknown[]): string => `\\x1b[0;1m${args.join(\" \")}\\x1b[0m`\nexport const gray          = (...args: unknown[]): string => `\\x1b[0;2m${args.join(\" \")}\\x1b[0m`\nexport const underline     = (...args: unknown[]): string => `\\x1b[0;4m${args.join(\" \")}\\x1b[0m`\nexport const black         = (...args: unknown[]): string => `\\x1b[0;30m${args.join(\" \")}\\x1b[0m`\nexport const red           = (...args: unknown[]): string => `\\x1b[0;31m${args.join(\" \")}\\x1b[0m`\nexport const green         = (...args: unknown[]): string => `\\x1b[0;32m${args.join(\" \")}\\x1b[0m`\nexport const yellow        = (...args: unknown[]): string => `\\x1b[0;33m${args.join(\" \")}\\x1b[0m`\nexport const purple        = (...args: unknown[]): string => `\\x1b[0;34m${args.join(\" \")}\\x1b[0m`\nexport const magenta       = (...args: unknown[]): string => `\\x1b[0;35m${args.join(\" \")}\\x1b[0m`\nexport const teal          = (...args: unknown[]): string => `\\x1b[0;36m${args.join(\" \")}\\x1b[0m`\nexport const white         = (...args: unknown[]): string => `\\x1b[0;37m${args.join(\" \")}\\x1b[0m`\nexport const boldUnderline = (...args: unknown[]): string => `\\x1b[1;4m${args.join(\" \")}\\x1b[0m`\nexport const boldBlack     = (...args: unknown[]): string => `\\x1b[1;30m${args.join(\" \")}\\x1b[0m`\nexport const boldRed       = (...args: unknown[]): string => `\\x1b[1;31m${args.join(\" \")}\\x1b[0m`\nexport const boldGreen     = (...args: unknown[]): string => `\\x1b[1;32m${args.join(\" \")}\\x1b[0m`\nexport const boldYellow    = (...args: unknown[]): string => `\\x1b[1;33m${args.join(\" \")}\\x1b[0m`\nexport const boldPurple    = (...args: unknown[]): string => `\\x1b[1;34m${args.join(\" \")}\\x1b[0m`\nexport const boldMagenta   = (...args: unknown[]): string => `\\x1b[1;35m${args.join(\" \")}\\x1b[0m`\nexport const boldTeal      = (...args: unknown[]): string => `\\x1b[1;36m${args.join(\" \")}\\x1b[0m`\nexport const boldWhite     = (...args: unknown[]): string => `\\x1b[1;37m${args.join(\" \")}\\x1b[0m`\n", "import * as term from \"./term\"\n\n// prettier-ignore\nfunction formatMessage(msg: string): string {\n\treturn msg.split(\"\\n\").map((each, x) => {\n\t\tif (x > 0 && each.length > 0) {\n\t\t\treturn \" \".repeat(2) + each\n\t\t}\n\t\treturn each\n\t}).join(\"\\n\")\n}\n\nexport function info(...args: unknown[]): void {\n\tconst message = formatMessage(args.join(\" \"))\n\n\tconsole.log(`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n  ${term.bold(\">\")} ${term.boldGreen(\"ok:\")} ${term.bold(message)}\n`)\n}\n\nexport function error(error: string | Error): void {\n\tconst message = formatMessage(typeof error === \"object\" ? error.message : error)\n\n\tconst traceEnabled = process.env[\"STACK_TRACE\"] === \"true\"\n\tif (!traceEnabled) {\n\t\tconsole.error(`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n  ${term.bold(\">\")} ${term.boldRed(\"error:\")} ${term.bold(message)}\n`)\n\t} else {\n\t\tconsole.error(`${term.gray([process.argv0, ...process.argv.slice(1)].join(\" \"))}\n\n  ${term.bold(\">\")} ${term.boldRed(\"error:\")} ${term.bold(message)}\n`)\n\t\tconsole.error({ error })\n\t}\n\tprocess.exit(0)\n}\n", "import readline from \"readline\"\n\nlet willEagerlyTerminate = false\n\n// getWillEagerlyTerminate gets whether the runtime will eagerly terminate.\nexport function getWillEagerlyTerminate(): boolean {\n\treturn willEagerlyTerminate\n}\n\n// setWillEagerlyTerminate sets whether the runtime will eagerly terminate.\nexport function setWillEagerlyTerminate(t: boolean): void {\n\twillEagerlyTerminate = t\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\n// https://gist.github.com/timneutkens/f2933558b8739bbf09104fb27c5c9664\nexport function clearScreen(): void {\n\tconst emptyScreen = \"\\n\".repeat(process.stdout.rows)\n\tconsole.log(emptyScreen)\n\treadline.cursorTo(process.stdout, 0, 0)\n\treadline.clearScreenDown(process.stdout)\n}\n", "import * as fs from \"fs\"\nimport * as p from \"path\"\nimport * as types from \"./types\"\n\n// prettier-ignore\ninterface StaticRoute {\n\tsrcPath:   string // e.g. \"src/pages/index.js\"\n\tdstPath:   string // e.g. \"dst/index.html\"\n\tcomponent: string // e.g. \"PageIndex\"\n\tpath:      string // e.g. \"/\"\n}\n\n// prettier-ignore\ninterface PathMetadata {\n\tpath:     string // e.g. \"path/to/basename.ext\"\n\tbasename: string // e.g. \"basename.ext\"\n\tname:     string // e.g. \"basename\"\n\text:      string // e.g. \".ext\"\n}\n\n// prettier-ignore\nconst supported: { [key: string]: boolean } = {\n\t\".js\":  true,\n\t\".jsx\": true,\n\t\".ts\":  true,\n\t\".tsx\": true,\n\t\".md\":  true,\n\t\".mdx\": true,\n}\n\n// parsePathMetadata parses path metadata.\nfunction parsePathMetadata(path: string): PathMetadata {\n\tconst basename = p.basename(path)\n\tconst ext = p.extname(path)\n\tconst name = basename.slice(0, -ext.length)\n\treturn { path, basename, name, ext }\n}\n\n// src/pages/index.js -> __export__/index.html\n// TODO: Write tests.\nfunction dstPath(runtime: types.Runtime<types.Command>, path: PathMetadata): string {\n\tconst syntax = p.join(runtime.dir.exportDir, path.path.slice(runtime.dir.srcPagesDir.length))\n\treturn syntax.slice(0, -path.ext.length) + \".html\"\n}\n\n// \"src/pages/component.js\" -> \"Component\"\n// TODO: Write tests.\nfunction component(path: PathMetadata): string {\n\tconst { name } = path\n\n\tlet syntax = \"\"\n\tfor (let x = 0; x < name.length; x++) {\n\t\tswitch (name[x]) {\n\t\t\tcase \"/\":\n\t\t\t\tx++\n\t\t\t\twhile (x < name.length) {\n\t\t\t\t\tif (name[x] !== \"/\") {\n\t\t\t\t\t\t// No-op\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tx++\n\t\t\t\t}\n\t\t\t\tif (x < name.length) {\n\t\t\t\t\tsyntax += name[x]!.toUpperCase()\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase \"-\":\n\t\t\t\tx++\n\t\t\t\twhile (x < name.length) {\n\t\t\t\t\tif (name[x] !== \"/\") {\n\t\t\t\t\t\t// No-op\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tx++\n\t\t\t\t}\n\t\t\t\tif (x < name.length) {\n\t\t\t\t\tsyntax += name[x]!.toUpperCase()\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tsyntax += name[x]\n\t\t\t\tbreak\n\t\t}\n\t}\n\tsyntax = \"Page\" + syntax[0]!.toUpperCase() + syntax.slice(1)\n\treturn syntax\n}\n\n// \"src/pages/index.js\" -> \"/\"\n// \"src/pages/hello-world.js\" -> \"/hello-world\"\n// TODO: Write tests.\nfunction path_(runtime: types.Runtime<types.Command>, path: PathMetadata): string {\n\tconst syntax = path.path.slice(runtime.dir.srcPagesDir.length, -path.ext.length)\n\tif (syntax.endsWith(\"/index\")) {\n\t\t// \"/\" case:\n\t\treturn syntax.slice(0, -\"index\".length)\n\t}\n\t// \"/hello-world\" case:\n\treturn syntax\n}\n\n// parseRoute parses a new filesystem route.\n// TODO: Write tests.\nfunction parseRoute(runtime: types.Runtime<types.Command>, path: PathMetadata): StaticRoute {\n\tconst route: StaticRoute = {\n\t\tsrcPath: path.path,\n\t\tdstPath: dstPath(runtime, path),\n\t\tcomponent: component(path),\n\t\tpath: path_(runtime, path),\n\t}\n\treturn route\n}\n\nasync function readPaths(dir: string): Promise<PathMetadata[]> {\n\tconst paths: PathMetadata[] = []\n\tasync function recurse(dir: string): Promise<void> {\n\t\tconst ls = await fs.promises.readdir(dir)\n\t\tfor (const each of ls) {\n\t\t\tconst current = p.join(dir, each)\n\t\t\tif ((await fs.promises.stat(current)).isDirectory()) {\n\t\t\t\tpaths.push(parsePathMetadata(current))\n\t\t\t\tawait recurse(current) // Recurse on the current directory\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpaths.push(parsePathMetadata(current))\n\t\t}\n\t}\n\tawait recurse(dir)\n\treturn paths\n}\n\n// createRouter creates a route from src/pages.\nexport default async function createRouter(runtime: types.Runtime<types.Command>): Promise<StaticRoute[]> {\n\tconst paths = await readPaths(\"src\")\n\tconst subpaths = paths.filter(path => {\n\t\tif (path.name.startsWith(\"_\") || path.name.startsWith(\"$\") || path.name.endsWith(\"_\") || path.name.endsWith(\"$\")) {\n\t\t\treturn false\n\t\t}\n\t\treturn supported[path.ext]\n\t})\n\tconst router: StaticRoute[] = []\n\tfor (const path of subpaths) {\n\t\trouter.push(parseRoute(runtime, path))\n\t}\n\treturn router\n}\n", "import * as esbuild from \"esbuild\"\nimport * as fs from \"fs\"\nimport * as p from \"path\"\nimport * as React from \"react\"\nimport * as ReactDOMServer from \"react-dom/server\"\nimport * as types from \"./types\"\n\nimport createRouter from \"./createRouter\"\n\n// // RenderPayload describes a render payload (page metadata).\n// interface RenderPayload {\n// \toutputPath: string\n// \tpath: string\n// \tmodule: types.StaticPageModule | types.DynamicPageModule\n// \tprops?: types.DescriptiveServerProps\n// }\n//\n// // \"/\" -> \"/index.html\"\n// // \"/nested/\" -> \"/nested/index.html\"\n// function pathToHTML(path: string): string {\n// \tif (!path.endsWith(\"/\")) return path + \".html\"\n// \treturn path + \"index.html\"\n// }\n//\n// // exportPage exports a page.\n// async function exportPage(runtime: types.Runtime, render: RenderPayload): Promise<void> {\n// \t// Render head:\n// \tlet head = \"<!-- <Head> -->\"\n// \tif (typeof render.module.Head === \"function\") {\n// \t\tconst markup = ReactDOMServer.renderToStaticMarkup(React.createElement(render.module.Head, render.props))\n// \t\thead = markup.replace(/></g, \">\\n\\t\\t<\").replace(/\\/>/g, \" />\")\n// \t}\n//\n// \t// Render page:\n// \tlet page = `\n// \t\t<noscript>You need to enable JavaScript to run this app.</noscript>\n// \t\t<div id=\"root\"></div>\n// \t\t<script src=\"/app.js\"></script>\n// \t`.trim()\n//\n// \t// prettier-ignore\n// \tif (typeof render.module.default === \"function\") {\n// \t\tconst str = ReactDOMServer.renderToString(React.createElement(render.module.default, render.props))\n// \t\tpage = page.replace(\n// \t\t\t`<div id=\"root\"></div>`,\n// \t\t\t`<div id=\"root\">${str}</div>`,\n// \t\t)\n// \t}\n//\n// \t// prettier-ignore\n// \tconst data = runtime.baseHTML\n// \t\t.replace(\"%head%\", head)\n// \t\t.replace(\"%page%\", page)\n//\n// \t// Export:\n// \tawait fs.promises.mkdir(p.dirname(render.outputPath), { recursive: true })\n// \tawait fs.promises.writeFile(render.outputPath, data)\n// }\n//\n// // exportPagesAndCreateRouter exports pages and creates a router from the return\n// // of mod.serverProps and mod.serverPaths.\n// async function exportPagesAndCreateRouter(runtime: types.Runtime): Promise<types.ServerRouter> {\n// \tconst router: types.ServerRouter = {}\n//\n// \tconst service = await esbuild.startService()\n//\n// \t// TODO: Add --concurrent?\n// \tfor (const route of runtime.filesystemRouter) {\n// \t\t// Generate paths for esbuild:\n// \t\tconst entryPoints = [route.inputPath]\n// \t\tconst outfile = p.join(\n// \t\t\truntime.directoryConfiguration.cacheDir,\n// \t\t\tentryPoints[0]!.replace(/\\.(jsx?|tsx?)$/, \".esbuild.js\"),\n// \t\t)\n//\n// \t\t// Use external: [\"react\", \"react-dom\"] to prevent a React error: You might\n// \t\t// have mismatching versions of React and the renderer (such as React DOM).\n// \t\tawait service.build({\n// \t\t\tbundle: true,\n// \t\t\tdefine: {\n// \t\t\t\t__DEV__: process.env.__DEV__!,\n// \t\t\t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV),\n// \t\t\t},\n// \t\t\tentryPoints,\n// \t\t\texternal: [\"react\", \"react-dom\"],\n// \t\t\tformat: \"cjs\", // Node.js\n// \t\t\tinject: [\"scripts/react-shim.js\"],\n// \t\t\tloader: { \".js\": \"jsx\" },\n// \t\t\tlogLevel: \"silent\", // TODO\n// \t\t\toutfile,\n// \t\t\t// plugins: [...configs.retro.plugins], // TODO\n// \t\t})\n// \t\t// TODO: Handle warnings, error, and hints.\n//\n// \t\tconst mod = require(\"../\" + outfile)\n//\n// \t\t// TODO: Add cache check here.\n//\n// \t\tlet descriptSrvProps: types.DescriptiveServerProps = { path: route.path }\n// \t\tif (typeof mod.serverProps === \"function\") {\n// \t\t\tconst props = await mod.serverProps()\n// \t\t\tdescriptSrvProps = {\n// \t\t\t\tpath: route.path, // Add path\n// \t\t\t\t...props,\n// \t\t\t}\n// \t\t}\n//\n// \t\t// TODO: Warn here for non-dynamic filesystem routes.\n// \t\tif (typeof mod.serverPaths === \"function\") {\n// \t\t\tconst descriptSrvPaths: types.DescriptiveServerPaths = await mod.serverPaths(descriptSrvProps)\n//\n// \t\t\t// Generate a component router:\n// \t\t\tconst compRouter: types.ServerRouter = {}\n// \t\t\tfor (const { path, props } of descriptSrvPaths) {\n// \t\t\t\tcompRouter[path] = {\n// \t\t\t\t\troute,\n// \t\t\t\t\tprops: {\n// \t\t\t\t\t\tpath,\n// \t\t\t\t\t\t...props,\n// \t\t\t\t\t},\n// \t\t\t\t}\n// \t\t\t}\n//\n// \t\t\tfor (const [path, { props }] of Object.entries(compRouter)) {\n// \t\t\t\t// Merge the component router to the app router:\n// \t\t\t\t//\n// \t\t\t\t// TODO: Warn here for repeat paths.\n// \t\t\t\trouter[path] = { route, props }\n//\n// \t\t\t\t// Create a renderPayload for exportPage:\n// \t\t\t\tconst outputPath = p.join(runtime.directoryConfiguration.exportDir, pathToHTML(path))\n// \t\t\t\tconst render: RenderPayload = {\n// \t\t\t\t\toutputPath,\n// \t\t\t\t\tpath,\n// \t\t\t\t\tmodule: mod,\n// \t\t\t\t\tprops,\n// \t\t\t\t}\n// \t\t\t\tawait exportPage(runtime, render)\n// \t\t\t}\n// \t\t\tcontinue\n// \t\t}\n//\n// \t\t// Merge the route to the app router:\n// \t\t//\n// \t\t// TODO: Warn here for repeat paths.\n// \t\tconst path = route.path\n// \t\trouter[path] = { route, props: descriptSrvProps }\n//\n// \t\t// Create a renderPayload for exportPage:\n// \t\tconst outputPath = p.join(runtime.directoryConfiguration.exportDir, pathToHTML(path))\n// \t\tconst render: RenderPayload = {\n// \t\t\toutputPath,\n// \t\t\tpath,\n// \t\t\tmodule: mod,\n// \t\t\tprops: descriptSrvProps,\n// \t\t}\n// \t\tawait exportPage(runtime, render)\n// \t}\n//\n// \treturn router\n// }\n//\n// // renderAppSource renders the App source code (before esbuild).\n// //\n// // TODO: Write tests (pure function).\n// export async function renderAppSource(router: types.ServerRouter): Promise<string> {\n// \t// Get the shared components:\n// \tconst sharedComps = [...new Set(Object.keys(router).map(keys => router[keys]!.route.component))]\n//\n// \t// Create a shared server router based on shared component keys:\n// \tconst sharedRouter: types.ServerRouter = {}\n// \tfor (const [, meta] of Object.entries(router)) {\n// \t\tconst comp = meta.route.component\n// \t\tif (sharedComps.includes(comp) && sharedRouter[comp] === undefined) {\n// \t\t\tsharedRouter[comp] = meta\n// \t\t}\n// \t}\n//\n// \treturn `import React from \"react\"\n// import ReactDOM from \"react-dom\"\n// import { Route, Router } from \"../router\"\n// // Shared components\n// ${Object.entries(sharedRouter)\n// \t.map(([, { route }]) => `import ${route.component} from \"../${route.inputPath}\"`)\n// \t.join(\"\\n\")}\n// import router from \"./router.json\"\n// export default function App() {\n// \treturn (\n// \t\t<Router>\n// ${\n// \tObject.entries(router)\n// \t\t.map(\n// \t\t\t([path, meta]) => `\n// \t\t\t<Route path=\"${path}\">\n// \t\t\t\t<${meta.route.component} {\n// \t\t\t\t\t...router[\"${path}\"].props\n// \t\t\t\t} />\n// \t\t\t</Route>`,\n// \t\t)\n// \t\t.join(\"\\n\") + \"\\n\"\n// }\n// \t\t</Router>\n// \t)\n// }\n// ${\n// \tJSON.parse(process.env.STRICT_MODE || \"true\")\n// \t\t? `ReactDOM.${JSON.parse(process.env.RENDER || \"false\") ? \"render\" : \"hydrate\"}(\n// \t<React.StrictMode>\n// \t\t<App />\n// \t</React.StrictMode>,\n// \tdocument.getElementById(\"root\"),\n// )`\n// \t\t: `ReactDOM.${JSON.parse(process.env.RENDER || \"false\") ? \"render\" : \"hydrate\"}(\n// \t<App />,\n// \tdocument.getElementById(\"root\"),\n// )`\n// }\n// ` // EOF\n// }\n\nconst export_: types.export_ = async runtime => {\n\tconsole.log(await createRouter(runtime))\n\t// const router = await exportPagesAndCreateRouter(runtime)\n\t//\n\t// // Cache router for --cached:\n\t// const dst = p.join(runtime.directoryConfiguration.cacheDir, \"router.json\")\n\t// const data = JSON.stringify(router, null, \"\\t\") + \"\\n\" // EOF\n\t// await fs.promises.writeFile(dst, data)\n\t//\n\t// const appSource = await renderAppSource(router)\n\t// const appSourcePath = p.join(runtime.directoryConfiguration.cacheDir, \"app.js\")\n\t// await fs.promises.writeFile(appSourcePath, appSource)\n\t//\n\t// // Generate paths for esbuild:\n\t// const entryPoints = [appSourcePath]\n\t// const outfile = entryPoints[0]!.replace(\n\t// \tnew RegExp(\"^\" + runtime.directoryConfiguration.cacheDir.replace(\"/\", \"\\\\/\")),\n\t// \truntime.directoryConfiguration.exportDir,\n\t// )\n\t//\n\t// await esbuild.build({\n\t// \tbundle: true,\n\t// \tdefine: {\n\t// \t\t__DEV__: process.env.__DEV__!,\n\t// \t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV),\n\t// \t},\n\t// \tentryPoints,\n\t// \tformat: \"iife\", // DOM\n\t// \tinject: [\"scripts/react-shim.js\"],\n\t// \tloader: { \".js\": \"jsx\" },\n\t// \tlogLevel: \"silent\", // TODO\n\t// \tminify: true,\n\t// \toutfile,\n\t// \t// TODO: We should probably only need to resolve plugins once.\n\t// \t// plugins: [...configs.retro.plugins],\n\t// })\n\t// // TODO: Handle warnings, error, and hints.\n}\n\nexport default export_\n\n// ;(async () => {\n// \ttry {\n// \t\tawait run(require(\"../__cache__/runtime.json\"))\n// \t} catch (error) {\n// \t\tconsole.error(error.stack)\n// \t}\n// })()\n", "import * as esbuild from \"esbuild\"\nimport * as http from \"http\"\nimport * as log from \"../lib/log\"\nimport * as p from \"path\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\n// spaify converts a URL for SPA-mode.\nfunction spaify(_: string): string {\n\treturn \"/\"\n}\n\n// ssgify converts a URL for SSG-mode.\nfunction ssgify(url: string): string {\n\tif (url.endsWith(\"/\")) return url + \"index.html\"\n\tif (p.extname(url) === \"\") return url + \".html\"\n\treturn url\n}\n\nfunction decorateStatus(status: number): string {\n\tif (status >= 200 && status < 300) {\n\t\treturn term.green(status)\n\t}\n\treturn term.red(status)\n}\n\n// This implementation is roughly based on:\n//\n// - https://esbuild.github.io/api/#customizing-server-behavior\n// - https://github.com/evanw/esbuild/issues/858#issuecomment-782814216\n//\nconst serve: types.serve = async runtime => {\n\tsetTimeout(() => {\n\t\tif (utils.getWillEagerlyTerminate()) return\n\t\tutils.clearScreen()\n\t\tlog.info(`http://localhost:${runtime.cmd.port}\n\nWhen you\u2019re ready to stop the server, press Ctrl-C.`)\n\t}, 10)\n\n\t// prettier-ignore\n\tconst result = await esbuild.serve({\n\t\tservedir: runtime.dir.exportDir,\n\t\tonRequest: (args: esbuild.ServeOnRequestArgs) => {\n\t\t\tlet descriptMs = args.timeInMS + \"ms\"\n\t\t\tif (args.status >= 200 && args.status < 300 && args.timeInMS === 0) {\n\t\t\t\tdescriptMs += \" - cached\"\n\t\t\t}\n\t\t\tconsole.log(`  ${term.bold(\"\u2192\")} http://localhost:${runtime.cmd.port} - '${args.method} ${args.path}' ${decorateStatus(args.status)} (${descriptMs})`)\n\t\t},\n\t}, {})\n\n\tlet transformURL = ssgify\n\tif (runtime.cmd.mode === \"spa\") {\n\t\ttransformURL = spaify\n\t}\n\n\t// The proxy server.\n\tconst proxySrv = http.createServer((req, res) => {\n\t\t// The proxy request.\n\t\tconst proxyReq = http.request({ ...req, path: transformURL(req.url!), port: result.port }, proxyRes => {\n\t\t\t// The proxy response.\n\t\t\tif (proxyRes.statusCode === 404) {\n\t\t\t\tres.writeHead(200, { \"Content-Type\": \"text/plain\" })\n\t\t\t\tres.end(\"404 page not found\")\n\t\t\t} else {\n\t\t\t\tres.writeHead(proxyRes.statusCode!, proxyRes.headers)\n\t\t\t\tproxyRes.pipe(res, { end: true })\n\t\t\t}\n\t\t})\n\t\treq.pipe(proxyReq, { end: true })\n\t})\n\tproxySrv.listen(runtime.cmd.port)\n}\n\nexport default serve\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCO,IAAM,OAAgB,IAAI,SAA4B,SAAY,KAAK,KAAK;AAC5E,IAAM,OAAgB,IAAI,SAA4B,SAAY,KAAK,KAAK;AAC5E,IAAM,YAAgB,IAAI,SAA4B,SAAY,KAAK,KAAK;AAE5E,IAAM,MAAgB,IAAI,SAA4B,UAAa,KAAK,KAAK;AAC7E,IAAM,QAAgB,IAAI,SAA4B,UAAa,KAAK,KAAK;AAQ7E,IAAM,UAAgB,IAAI,SAA4B,UAAa,KAAK,KAAK;AAC7E,IAAM,YAAgB,IAAI,SAA4B,UAAa,KAAK,KAAK;;;ACZpF,uBAAuB;AACtB,SAAO,IAAI,MAAM,MAAM,IAAI,CAAC,MAAM;AACjC,QAAI,IAAI,KAAK,KAAK,SAAS;AAC1B,aAAO,IAAI,OAAO,KAAK;AAAA;AAExB,WAAO;AAAA,KACL,KAAK;AAAA;AAGF,iBAAiB;AACvB,QAAM,UAAU,cAAc,KAAK,KAAK;AAExC,UAAQ,IAAI,GAAG,AAAK,KAAK,CAAC,QAAQ,OAAO,GAAG,QAAQ,KAAK,MAAM,IAAI,KAAK;AAAA;AAAA,IAErE,AAAK,KAAK,QAAQ,AAAK,UAAU,UAAU,AAAK,KAAK;AAAA;AAAA;AAIlD,eAAe;AACrB,QAAM,UAAU,cAAc,OAAO,WAAU,WAAW,OAAM,UAAU;AAE1E,QAAM,eAAe,QAAQ,IAAI,mBAAmB;AACpD,MAAI,CAAC;AACJ,YAAQ,MAAM,GAAG,AAAK,KAAK,CAAC,QAAQ,OAAO,GAAG,QAAQ,KAAK,MAAM,IAAI,KAAK;AAAA;AAAA,IAExE,AAAK,KAAK,QAAQ,AAAK,QAAQ,aAAa,AAAK,KAAK;AAAA;AAAA;AAGxD,YAAQ,MAAM,GAAG,AAAK,KAAK,CAAC,QAAQ,OAAO,GAAG,QAAQ,KAAK,MAAM,IAAI,KAAK;AAAA;AAAA,IAExE,AAAK,KAAK,QAAQ,AAAK,QAAQ,aAAa,AAAK,KAAK;AAAA;AAExD,YAAQ,MAAM,CAAE;AAAA;AAEjB,UAAQ,KAAK;AAAA;;;ACrCd,sBAAqB;AAErB,IAAI,uBAAuB;AAGpB;AACN,SAAO;AAAA;AAID,iCAAiC;AACvC,yBAAuB;AAAA;AAMjB;AACN,QAAM,cAAc,KAAK,OAAO,QAAQ,OAAO;AAC/C,UAAQ,IAAI;AACZ,0BAAS,SAAS,QAAQ,QAAQ,GAAG;AACrC,0BAAS,gBAAgB,QAAQ;AAAA;;;ACrBlC,SAAoB;AACpB,QAAmB;AAoBnB,IAAM,YAAwC;AAAA,EAC7C,OAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAQ;AAAA,EACR,QAAQ;AAAA;AAIT,2BAA2B;AAC1B,QAAM,YAAW,AAAE,WAAS;AAC5B,QAAM,MAAM,AAAE,UAAQ;AACtB,QAAM,OAAO,UAAS,MAAM,GAAG,CAAC,IAAI;AACpC,SAAO,CAAE,MAAM,qBAAU,MAAM;AAAA;AAKhC,iBAAiB,SAAuC;AACvD,QAAM,SAAS,AAAE,OAAK,QAAQ,IAAI,WAAW,KAAK,KAAK,MAAM,QAAQ,IAAI,YAAY;AACrF,SAAO,OAAO,MAAM,GAAG,CAAC,KAAK,IAAI,UAAU;AAAA;AAK5C,mBAAmB;AAClB,QAAM,CAAE,QAAS;AAEjB,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ;AAChC,YAAQ,KAAK;AAAA,WACP;AACJ;AACA,eAAO,IAAI,KAAK;AACf,cAAI,KAAK,OAAO;AAEf;AAAA;AAED;AAAA;AAED,YAAI,IAAI,KAAK;AACZ,oBAAU,KAAK,GAAI;AAAA;AAEpB;AAAA,WACI;AACJ;AACA,eAAO,IAAI,KAAK;AACf,cAAI,KAAK,OAAO;AAEf;AAAA;AAED;AAAA;AAED,YAAI,IAAI,KAAK;AACZ,oBAAU,KAAK,GAAI;AAAA;AAEpB;AAAA;AAEA,kBAAU,KAAK;AACf;AAAA;AAAA;AAGH,WAAS,SAAS,OAAO,GAAI,gBAAgB,OAAO,MAAM;AAC1D,SAAO;AAAA;AAMR,eAAe,SAAuC;AACrD,QAAM,SAAS,KAAK,KAAK,MAAM,QAAQ,IAAI,YAAY,QAAQ,CAAC,KAAK,IAAI;AACzE,MAAI,OAAO,SAAS;AAEnB,WAAO,OAAO,MAAM,GAAG,CAAC,QAAQ;AAAA;AAGjC,SAAO;AAAA;AAKR,oBAAoB,SAAuC;AAC1D,QAAM,QAAqB;AAAA,IAC1B,SAAS,KAAK;AAAA,IACd,SAAS,QAAQ,SAAS;AAAA,IAC1B,WAAW,UAAU;AAAA,IACrB,MAAM,MAAM,SAAS;AAAA;AAEtB,SAAO;AAAA;AAGR,yBAAyB;AACxB,QAAM,QAAwB;AAC9B,yBAAuB;AACtB,UAAM,KAAK,MAAM,AAAG,YAAS,QAAQ;AACrC,eAAW,QAAQ;AAClB,YAAM,UAAU,AAAE,OAAK,MAAK;AAC5B,UAAK,OAAM,AAAG,YAAS,KAAK,UAAU;AACrC,cAAM,KAAK,kBAAkB;AAC7B,cAAM,QAAQ;AACd;AAAA;AAED,YAAM,KAAK,kBAAkB;AAAA;AAAA;AAG/B,QAAM,QAAQ;AACd,SAAO;AAAA;AAIR,4BAA2C;AAC1C,QAAM,QAAQ,MAAM,UAAU;AAC9B,QAAM,WAAW,MAAM,OAAO;AAC7B,QAAI,KAAK,KAAK,WAAW,QAAQ,KAAK,KAAK,WAAW,QAAQ,KAAK,KAAK,SAAS,QAAQ,KAAK,KAAK,SAAS;AAC3G,aAAO;AAAA;AAER,WAAO,UAAU,KAAK;AAAA;AAEvB,QAAM,SAAwB;AAC9B,aAAW,QAAQ;AAClB,WAAO,KAAK,WAAW,SAAS;AAAA;AAEjC,SAAO;AAAA;;;AC4ER,IAAM,UAAyB,OAAM;AACpC,UAAQ,IAAI,MAAM,aAAa;AAAA;AAsChC,IAAO,iBAAQ;;;ACnQf,cAAyB;AACzB,WAAsB;AAEtB,SAAmB;AAMnB,gBAAgB;AACf,SAAO;AAAA;AAIR,gBAAgB;AACf,MAAI,IAAI,SAAS;AAAM,WAAO,MAAM;AACpC,MAAI,AAAE,WAAQ,SAAS;AAAI,WAAO,MAAM;AACxC,SAAO;AAAA;AAGR,wBAAwB;AACvB,MAAI,UAAU,OAAO,SAAS;AAC7B,WAAO,AAAK,MAAM;AAAA;AAEnB,SAAO,AAAK,IAAI;AAAA;AAQjB,IAAM,SAAqB,OAAM;AAChC,aAAW;AACV,QAAI,AAAM;AAA2B;AACrC,IAAM;AACN,IAAI,KAAK,oBAAoB,QAAQ,IAAI;AAAA;AAAA;AAAA,KAGvC;AAGH,QAAM,SAAS,MAAM,AAAQ,cAAM;AAAA,IAClC,UAAU,QAAQ,IAAI;AAAA,IACtB,WAAW,CAAC;AACX,UAAI,aAAa,KAAK,WAAW;AACjC,UAAI,KAAK,UAAU,OAAO,KAAK,SAAS,OAAO,KAAK,aAAa;AAChE,sBAAc;AAAA;AAEf,cAAQ,IAAI,KAAK,AAAK,KAAK,8BAAyB,QAAQ,IAAI,WAAW,KAAK,UAAU,KAAK,SAAS,eAAe,KAAK,YAAY;AAAA;AAAA,KAEvI;AAEH,MAAI,eAAe;AACnB,MAAI,QAAQ,IAAI,SAAS;AACxB,mBAAe;AAAA;AAIhB,QAAM,WAAW,AAAK,kBAAa,CAAC,KAAK;AAExC,UAAM,WAAW,AAAK,aAAQ,IAAK,KAAK,MAAM,aAAa,IAAI,MAAO,MAAM,OAAO,OAAQ;AAE1F,UAAI,SAAS,eAAe;AAC3B,YAAI,UAAU,KAAK,CAAE,gBAAgB;AACrC,YAAI,IAAI;AAAA;AAER,YAAI,UAAU,SAAS,YAAa,SAAS;AAC7C,iBAAS,KAAK,KAAK,CAAE,KAAK;AAAA;AAAA;AAG5B,QAAI,KAAK,UAAU,CAAE,KAAK;AAAA;AAE3B,WAAS,OAAO,QAAQ,IAAI;AAAA;AAG7B,IAAO,gBAAQ;;;ANpER,IAAM,OAAO;AAAA;AAAA;AAAA;AAAA,EAIlB;AAEK,IAAM,QAAQ,GAAG,AAAK,KAAK,CAAC,QAAQ,OAAO,GAAG,QAAQ,KAAK,MAAM,IAAI,KAAK;AAAA;AAAA,IAE7E,AAAK,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAMV,AAAK,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQV,AAAK,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOV,AAAK,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOV,AAAK,KAAK;AAAA;AAAA,MAER,AAAK,UAAU;AAAA;AAKrB,gCAAgC;AAC/B,QAAM,MAAwB;AAAA,IAC7B,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,WAAW;AAAA,IACX,MAAM;AAAA;AAEP,MAAI,SAAS;AACb,aAAW,OAAO;AACjB,QAAI,IAAI,WAAW;AAClB,UAAI,QAAQ;AACX,YAAI,SAAS;AAAA,iBACH,QAAQ,mBAAmB,QAAQ;AAC7C,YAAI,SAAS,KAAK,MAAM,IAAI,MAAM,YAAY;AAAA;AAE9C,iBAAS;AACT;AAAA;AAAA,eAES,IAAI,WAAW;AACzB,UAAI,QAAQ;AACX,YAAI,YAAY;AAAA,iBACN,QAAQ,sBAAsB,QAAQ;AAChD,YAAI,YAAY,KAAK,MAAM,IAAI,MAAM,eAAe;AAAA;AAEpD,iBAAS;AACT;AAAA;AAAA,eAES,IAAI,WAAW;AACzB,UAAI,eAAe,KAAK;AACvB,YAAI,OAAO,KAAK,MAAM,IAAI,MAAM,UAAU;AAAA;AAE1C,iBAAS;AACT;AAAA;AAAA;AAGD,eAAS;AAAA;AAAA;AAGX,MAAI,WAAW;AACd,IAAI,MAAM,gBAAgB;AAAA;AAE3B,MAAI,IAAI,OAAO,OAAO,IAAI,QAAQ;AACjC,IAAI,MAAM;AAAA;AAEX,SAAO;AAAA;AAKR,mCAAmC;AAClC,QAAM,MAA2B;AAAA,IAChC,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,WAAW;AAAA;AAEZ,MAAI,SAAS;AACb,aAAW,OAAO;AACjB,QAAI,IAAI,WAAW;AAClB,UAAI,QAAQ;AACX,YAAI,SAAS;AAAA,iBACH,QAAQ,mBAAmB,QAAQ;AAC7C,YAAI,SAAS,KAAK,MAAM,IAAI,MAAM,YAAY;AAAA;AAE9C,iBAAS;AACT;AAAA;AAAA,eAES,IAAI,WAAW;AACzB,UAAI,QAAQ;AACX,YAAI,YAAY;AAAA,iBACN,QAAQ,sBAAsB,QAAQ;AAChD,YAAI,YAAY,KAAK,MAAM,IAAI,MAAM,eAAe;AAAA;AAEpD,iBAAS;AACT;AAAA;AAAA;AAGD,eAAS;AAAA;AAAA;AAGX,MAAI,WAAW;AACd,IAAI,MAAM,gBAAgB;AAAA;AAE3B,SAAO;AAAA;AAKR,kCAAkC;AACjC,QAAM,MAA0B;AAAA,IAC/B,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA;AAEP,MAAI,SAAS;AACb,aAAW,OAAO;AACjB,QAAI,IAAI,WAAW;AAClB,UAAI,QAAQ;AACX,YAAI,OAAO;AAAA,iBACD,QAAQ;AAClB,YAAI,OAAO;AAAA;AAEX,iBAAS;AACT;AAAA;AAAA,eAES,IAAI,WAAW;AACzB,UAAI,eAAe,KAAK;AACvB,YAAI,OAAO,KAAK,MAAM,IAAI,MAAM,UAAU;AAAA;AAE1C,iBAAS;AACT;AAAA;AAAA;AAGD,eAAS;AAAA;AAAA;AAGX,MAAI,WAAW;AACd,IAAI,MAAM,gBAAgB;AAAA;AAE3B,MAAI,IAAI,OAAO,OAAO,IAAI,QAAQ;AACjC,IAAI,MAAM;AAAA;AAEX,SAAO;AAAA;AAIR,IAAM,OAAO;AAAA,EACZ,WAAa,QAAQ,IAAI,cAAc;AAAA,EACvC,aAAa,QAAQ,IAAI,aAAc;AAAA,EACvC,UAAa,QAAQ,IAAI,aAAc;AAAA,EACvC,WAAa,QAAQ,IAAI,cAAc;AAAA;AAGxC;AACC,QAAM,OAAO,QAAQ,UAAU,SAAS,QAAQ,KAAK,MAAM,KAAK,QAAQ;AAGxE,MAAI,KAAK,WAAW;AACnB,YAAQ,IAAI;AACZ,YAAQ,KAAK;AAAA;AAGd,MAAI;AACJ,QAAM,MAAM,KAAK;AACjB,MAAI,QAAQ,aAAa,QAAQ,eAAe,QAAQ;AACvD,YAAQ,IAAI,QAAQ,IAAI,oBAAoB;AAC5C,YAAQ,KAAK;AAAA,aACH,QAAQ,WAAW,QAAQ,aAAa,QAAQ,UAAU,QAAQ;AAC5E,YAAQ,IAAI;AACZ,YAAQ,KAAK;AAAA,aACH,QAAQ;AAClB,YAAQ,IAAI,aAAa;AACzB,YAAQ,IAAI,cAAc;AAC1B,UAAM,oBAAoB,GAAG,KAAK,MAAM;AAAA,aAC9B,QAAQ;AAClB,YAAQ,IAAI,aAAa;AACzB,YAAQ,IAAI,cAAc;AAC1B,UAAM,uBAAuB,GAAG,KAAK,MAAM;AAAA,aACjC,QAAQ;AAClB,YAAQ,IAAI,aAAa;AACzB,YAAQ,IAAI,cAAc;AAC1B,UAAM,sBAAsB,GAAG,KAAK,MAAM;AAAA;AAE1C,IAAI,MAAM,oBAAoB;AAAA;AAAA,EAE9B;AAAA;AAAA;AAAA;AAKD,QAAM,UAAwC;AAAA,IAC7C;AAAA,IACA,KAAK;AAAA;AAGN,UAAQ,IAAK;AAAA,SACP;AAEJ;AAAA,SACI;AACJ,YAAM,KAAK;AACX,YAAM,eAAQ;AACd;AAAA,SACI;AACJ,YAAM,KAAK;AACX,YAAM,cAAM;AACZ;AAAA;AAAA;AAIH,QAAQ,GAAG,qBAAqB;AAC/B,EAAM,wBAAwB;AAG9B,UAAQ,IAAI,iBAAiB;AAC7B,MAAI,UAAU,sBAAsB,IAAI;AACxC,EAAI,MAAM;AAAA;AAGX;",
  "names": []
}
