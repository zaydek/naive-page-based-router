{
  "version": 3,
  "sources": ["../lib/term.ts", "errors.ts", "../lib/log.ts", "utils/detab.ts", "utils/env.ts", "utils/formatEsbuild.ts", "utils/formatter.ts", "utils/fs.ts", "utils/modes.ts", "utils/pathInfo.ts", "utils/testURISafe.ts", "utils/timestamp.ts", "utils/watcher.ts", "cli.ts", "runtime.ts", "pages.ts", "run-dev.ts", "events.ts", "router.ts", "router-text.ts", "run-export.ts", "run-serve.ts", "main.ts"],
  "sourcesContent": ["// BuilderFunction describes the builder pattern where a function or a method\n// (recursively) can be called.\n//\n// For example:\n//\n// - function(...)\n// - function.method(...)\n// - function.method.method(...)\n//\nexport interface Builder {\n\t(...args: unknown[]): string\n\tnormal: Builder\n\tbold: Builder\n\tdim: Builder\n\tunderline: Builder\n\tblack: Builder\n\tred: Builder\n\tgreen: Builder\n\tyellow: Builder\n\tblue: Builder\n\tmagenta: Builder\n\tcyan: Builder\n\twhite: Builder\n\tbgBlack: Builder\n\tbgRed: Builder\n\tbgGreen: Builder\n\tbgYellow: Builder\n\tbgBlue: Builder\n\tbgMagenta: Builder\n\tbgCyan: Builder\n\tbgWhite: Builder\n}\n\nconst options = [\n\t{ name: \"normal\", code: \"\\x1b[0m\" },\n\t{ name: \"bold\", code: \"\\x1b[1m\" },\n\t{ name: \"dim\", code: \"\\x1b[2m\" },\n\t{ name: \"underline\", code: \"\\x1b[4m\" },\n\t{ name: \"black\", code: \"\\x1b[30m\" },\n\t{ name: \"red\", code: \"\\x1b[31m\" },\n\t{ name: \"green\", code: \"\\x1b[32m\" },\n\t{ name: \"yellow\", code: \"\\x1b[33m\" },\n\t{ name: \"blue\", code: \"\\x1b[34m\" },\n\t{ name: \"magenta\", code: \"\\x1b[35m\" },\n\t{ name: \"cyan\", code: \"\\x1b[36m\" },\n\t{ name: \"white\", code: \"\\x1b[37m\" },\n\t{ name: \"bgBlack\", code: \"\\x1b[40m\" },\n\t{ name: \"bgRed\", code: \"\\x1b[41m\" },\n\t{ name: \"bgGreen\", code: \"\\x1b[42m\" },\n\t{ name: \"bgYellow\", code: \"\\x1b[43m\" },\n\t{ name: \"bgBlue\", code: \"\\x1b[44m\" },\n\t{ name: \"bgMagenta\", code: \"\\x1b[45m\" },\n\t{ name: \"bgCyan\", code: \"\\x1b[46m\" },\n\t{ name: \"bgWhite\", code: \"\\x1b[47m\" },\n]\n\n// function clean(str: string): string {\n// \tlet out = \"\"\n//\n// \tlet x = 0\n// \twhile (x < str.length) {\n// \t\tlet codes: string[] = []\n// \t\tlet x2 = x\n//\n// \t\t// On \"\\x1b\":\n// \t\twhile (str[x2] === \"\\x1b\") {\n// \t\t\tx2++\n//\n// \t\t\t// Step over \"[\":\n// \t\t\tif (x2 >= str.length || str[x2] !== \"[\") {\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t\tx2++\n// \t\t\t// Step over /\\d+/:\n// \t\t\tconst start = x2\n// \t\t\twhile (x2 < str.length) {\n// \t\t\t\tif (str[x2]! < \"0\" || str[x2]! > \"9\") {\n// \t\t\t\t\tbreak\n// \t\t\t\t}\n// \t\t\t\tx2++\n// \t\t\t}\n// \t\t\t// Guard /\\d+/:\n// \t\t\tconst end = x2\n// \t\t\tif (start === end) {\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t\t// Step over \"m\":\n// \t\t\tif (x2 >= str.length || str[x2] !== \"m\") {\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t\tx2++\n// \t\t\tcodes.push(str.slice(start, end))\n// \t\t}\n//\n// \t\t// On one or more code matches:\n// \t\tif (codes.length > 0) {\n// \t\t\tout += `\\x1b[${codes.join(\";\")}m`\n// \t\t\tx = x2\n// \t\t\tcontinue\n// \t\t}\n//\n// \t\t// Shortcut:\n// \t\tif (x2 > x) {\n// \t\t\tout += str.slice(x, x2)\n// \t\t\tx = x2\n// \t\t\tcontinue\n// \t\t}\n// \t\tout += str[x]\n// \t\tx++\n// \t}\n// \treturn out\n// }\n\nfunction build(...codes: string[]): Builder {\n\tconst set = new Set(codes)\n\n\tfunction format(...args: unknown[]): string {\n\t\tconst coded = [...set].join(\"\")\n\t\t// return clean(coded + args.join(\" \").replaceAll(\"\\x1b[0m\", \"\\x1b[0m\" + coded) + \"\\x1b[0m\")\n\t\treturn coded + args.join(\" \").replaceAll(\"\\x1b[0m\", \"\\x1b[0m\" + coded) + \"\\x1b[0m\"\n\t}\n\n\tfor (const { name, code } of options) {\n\t\tObject.defineProperty(format, name, {\n\t\t\tenumerable: true,\n\t\t\tget() {\n\t\t\t\treturn build(...[...codes, code])\n\t\t\t},\n\t\t})\n\t}\n\n\t// NOTE: Use 'as builder' because there\u2019s no initializer syntax for functions\n\t// with methods.\n\treturn format as Builder\n}\n\nexport const noop = (...args: unknown[]): string => args.join(\" \")\nexport const normal = build(\"\\x1b[0m\")\nexport const bold = build(\"\\x1b[1m\")\nexport const dim = build(\"\\x1b[2m\")\nexport const underline = build(\"\\x1b[4m\")\nexport const black = build(\"\\x1b[30m\")\nexport const red = build(\"\\x1b[31m\")\nexport const green = build(\"\\x1b[32m\")\nexport const yellow = build(\"\\x1b[33m\")\nexport const blue = build(\"\\x1b[34m\")\nexport const magenta = build(\"\\x1b[35m\")\nexport const cyan = build(\"\\x1b[36m\")\nexport const white = build(\"\\x1b[37m\")\nexport const bgBlack = build(\"\\x1b[40m\")\nexport const bgRed = build(\"\\x1b[41m\")\nexport const bgGreen = build(\"\\x1b[42m\")\nexport const bgYellow = build(\"\\x1b[43m\")\nexport const bgBlue = build(\"\\x1b[44m\")\nexport const bgMagenta = build(\"\\x1b[45m\")\nexport const bgCyan = build(\"\\x1b[46m\")\nexport const bgWhite = build(\"\\x1b[47m\")\n", "import * as term from \"../lib/term\"\nimport * as types from \"./types\"\n\n////////////////////////////////////////////////////////////////////////////////\n// CLI\n////////////////////////////////////////////////////////////////////////////////\n\nexport function badCLIRunCommand(run: string): string {\n\treturn `Bad run command ${term.magenta(`'${run}'`)}.\n\nSupported commands:\n\nretro dev     Start the dev server\nretro export  Export the production-ready build (SSG)\nretro serve   Serve the production-ready build\n\n${term.yellow(\"hint:\")} Use ${term.magenta(\"'retro usage'\")} for usage.`\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Document (index.html)\n////////////////////////////////////////////////////////////////////////////////\n\nexport function missingDocumentHeadTag(path: string): string {\n\treturn `${path}: Add ${term.magenta(\"'%head%'\")} to ${term.magenta(\"'<head>'\")}.\n\nFor example:\n\n${term.dim(`// ${path}`)}\n<!DOCTYPE html>\n\t<head lang=\"en\">\n\t\t<meta charset=\"utf-8\" />\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\t\t${term.magenta(\"%head%\")}\n\t\t${term.dim(\"...\")}\n\t</head>\n\t<body>\n\t\t${term.dim(\"...\")}\n\t</body>\n</html>`\n}\n\nexport function missingDocumentPageTag(path: string): string {\n\treturn `${path}: Add ${term.magenta(\"'%page%'\")} to ${term.magenta(\"'<body>'\")}.\n\nFor example:\n\n${term.dim(`// ${path}`)}\n<!DOCTYPE html>\n\t<head lang=\"en\">\n\t\t${term.dim(\"...\")}\n\t</head>\n\t<body>\n\t\t${term.magenta(\"%page%\")}\n\t\t${term.dim(\"...\")}\n\t</body>\n</html>`\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Pages\n////////////////////////////////////////////////////////////////////////////////\n\nexport function pagesUseNonURICharacters(pages: string[]): string {\n\treturn `These pages use non-URI characters:\n\n${pages.map(page => \"- \" + page).join(\"\\n\")}\n\nURI characters are described by RFC 3986:\n\n2.2. Unreserved Characters\n\n\tALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\n2.3. Reserved Characters\n\n\tgen-delims = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" /\n\tsub-delims = \"@\" / \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n\t${\"\\x20\".repeat(11)}/ \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\n${term.underline.cyan(\"https://tools.ietf.org/html/rfc3986\")}`\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Server API (static pages)\n////////////////////////////////////////////////////////////////////////////////\n\nexport function serverPropsFunction(src: string): string {\n\treturn `${src}.serverProps: ${term.magenta(\"'serverProps'\")} must be a function.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverProps() {\n\treturn { ${term.dim(\"...\")} }\n}\n\nOr:\n\n${term.dim(`// ${src}`)}\nexport async function serverProps() {\n\tawait ${term.dim(\"...\")}\n\treturn { ${term.dim(\"...\")} }\n}`\n}\n\nexport function serverPropsReturn(src: string): string {\n\treturn `${src}.serverProps: Bad ${term.magenta(\"'serverProps'\")} resolver.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverProps() {\n\treturn { ${term.dim(\"...\")} }\n}`\n}\n\nexport function serverPathsMismatch(src: string): string {\n\treturn `${src}: Use ${term.magenta(\"'serverProps'\")} for non-dynamic pages, not ${term.magenta(\"'serverPaths'\")}.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverProps() {\n\treturn { ${term.dim(\"...\")} }\n}`\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Server API (dynamic pages)\n////////////////////////////////////////////////////////////////////////////////\n\nexport function serverPathsFunction(src: string): string {\n\treturn `${src}.serverPaths: ${term.magenta(\"'serverPaths'\")} must be a function.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverPaths() {\n\treturn { ${term.dim(\"...\")} }\n}\n\nOr:\n\n${term.dim(`// ${src}`)}\nexport async function serverPaths() {\n\tawait ${term.dim(\"...\")}\n\treturn { ${term.dim(\"...\")} }\n}`\n}\n\nexport function serverPathsReturn(src: string): string {\n\treturn `\n${src}.serverPaths: Bad ${term.magenta(\"'serverPaths'\")} resolver.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverPaths() {\n\treturn [\n\t\t{ path: \"/foo\", props: ${term.dim(\"...\")} },\n\t\t{ path: \"/foo/bar\", props: ${term.dim(\"...\")} },\n\t\t{ path: \"/foo/bar/baz\", props: ${term.dim(\"...\")} },\n\t]\n}`\n}\n\nexport function serverPropsMismatch(src: string): string {\n\treturn `${src}: Use ${term.magenta(\"'serverPaths'\")} for dynamic pages, not ${term.magenta(\"'serverProps'\")}.\n\nFor example:\n\n${term.dim(`// ${src}`)}\nexport function serverPaths() {\n\treturn [\n\t\t{ path: \"/foo\", props: ${term.dim(\"...\")} },\n\t\t{ path: \"/foo/bar\", props: ${term.dim(\"...\")} },\n\t\t{ path: \"/foo/bar/baz\", props: ${term.dim(\"...\")} },\n\t]\n}`\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Server API (miscellaneous)\n////////////////////////////////////////////////////////////////////////////////\n\nexport function duplicatePathFound(r1: types.Route, r2: types.Route): string {\n\tfunction caller(r: types.Route): string {\n\t\treturn r.type === \"static\" ? \"serverProps\" : \"serverPaths\"\n\t}\n\treturn `${r1.src}.${caller(r1)}: Path ${term.magenta(`'${r1.path}'`)} used by ${r2.src}.${caller(r2)}.`\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Serve command\n////////////////////////////////////////////////////////////////////////////////\n\nexport function serveWithMissingExportDirectory(): string {\n\treturn `It looks like you\u2019re trying to run ${term.magenta(\"'retro serve'\")} before ${term.magenta(\n\t\t\"'retro export'\",\n\t)}. Try ${term.magenta(\"'retro export && retro serve'\")}.`\n}\n", "import * as term from \"../lib/term\"\n\n// format converts tabs to spaces and adds two spaces to the start.\nfunction format(...args: unknown[]): string {\n\tif (args.length === 1 && args[0] instanceof Error) {\n\t\treturn format(args[0].message)\n\t}\n\n\treturn args\n\t\t.join(\" \")\n\t\t.split(\"\\n\")\n\t\t.map((each, x) => {\n\t\t\t// if (x === 0) return term.bold(each)\n\t\t\tif (x === 0) return each\n\t\t\tif (each === \"\") return each\n\t\t\treturn \"\\x20\" + each.replace(\"\\t\", \"  \")\n\t\t})\n\t\t.join(\"\\n\")\n}\n\n// \"> ok: ...\"\nexport function ok(...args: unknown[]): void {\n\tconst message = format(...args)\n\tconsole.log(`\\x20${term.bold(\">\")} ${term.bold(message)}`)\n\tconsole.log()\n}\n\n// \"> warning: ...\"\nexport function warning(...args: unknown[]): void {\n\tconst message = format(...args)\n\tconsole.warn(`\\x20${term.bold(\">\")} ${term.bold.yellow(\"warning:\")} ${term.bold(message)}`)\n\tconsole.warn()\n}\n\n// \"> error: ...\"\nexport function error(...args: unknown[]): void {\n\tconst message = format(...args)\n\tconst traceEnabled = process.env[\"STACK_TRACE\"] === \"true\"\n\tif (!traceEnabled) {\n\t\tconsole.error(`\\x20${term.bold(\">\")} ${term.bold.red(\"error:\")} ${term.bold(message)}`)\n\t\tconsole.error()\n\t} else {\n\t\tconsole.error(`\\x20${term.bold(\">\")} ${term.bold.red(\"error:\")} ${term.bold(message)}`)\n\t\tconsole.error()\n\t}\n\tprocess.exit(0)\n}\n", "export function detab(str: string): string {\n\tlet offsets: number[] = []\n\n\tconst arr = str.trimEnd().split(\"\\n\")\n\tfor (const each of arr) {\n\t\tif (each.length === 0) continue\n\t\tlet offset = 0\n\t\twhile (offset < each.length) {\n\t\t\tif (each[offset] !== \"\\t\") {\n\t\t\t\t// No-op\n\t\t\t\tbreak\n\t\t\t}\n\t\t\toffset++\n\t\t}\n\t\toffsets.push(offset)\n\t}\n\n\toffsets = offsets.filter(each => each !== 0)\n\tconst offset = Math.min(...offsets)\n\treturn arr.map(each => each.slice(offset)).join(\"\\n\") + \"\\n\" // EOF\n}\n", "// setEnvDevelopment sets environment variables for development mode.\nexport function setEnvDevelopment(): void {\n\tprocess.env[\"__DEV__\"] = \"true\"\n\tprocess.env[\"NODE_ENV\"] = \"development\"\n}\n\n// setEnvProduction sets environment variables for production mode.\nexport function setEnvProduction(): void {\n\tprocess.env[\"__DEV__\"] = \"false\"\n\tprocess.env[\"NODE_ENV\"] = \"production\"\n}\n", "import * as esbuild from \"esbuild\"\nimport * as term from \"../../lib/term\"\n\n// loc.file:loc.line:loc.column: msg.text\n//\n// loc.line | loc.lineText\n//            ~~~~~~~~~~~~\n//\n// TODO: Add support for hints.\nexport function formatEsbuildMessage(msg: esbuild.Message, color: (...args: unknown[]) => void): string {\n\tconst loc = msg.location!\n\treturn `${loc.file}:${loc.line}:${loc.column}: ${msg.text}\n\n\t${loc.line} ${term.dim(\"\u2502\")} ${loc.lineText}\n\t${\" \".repeat(String(loc.line).length)} ${term.dim(\"\u2502\")} ${\" \".repeat(loc.column)}${color(\"~\".repeat(loc.length))}`\n\t// ${\" \".repeat(String(loc.line).length)} ${term.dim(\"\u2502\")} ${\" \".repeat(loc.column)}${color(\"^\")}`\n}\n", "interface Formatter {\n\tformat(...args: unknown[]): void\n\tdone(...args: unknown[]): void\n}\n\nexport function newFormatter(logger = (...args: unknown[]): void => console.log(...args)): Formatter {\n\tlet once = false\n\treturn {\n\t\tformat(...args: unknown[]): void {\n\t\t\tif (once) return\n\t\t\tlogger(...args)\n\t\t\tonce = true\n\t\t},\n\t\tdone(...args: unknown[]): void {\n\t\t\tlogger(...args)\n\t\t},\n\t}\n}\n", "import * as fs from \"fs\"\nimport * as path from \"path\"\n\nexport async function readdirAll(entry: string, ...excludes: string[]): Promise<string[]> {\n\tconst ctx: string[] = []\n\n\tasync function recurse(entry: string): Promise<void> {\n\t\tconst ls = await fs.promises.readdir(entry)\n\t\tconst items = ls.map(item => path.join(entry, item)) // Add entry\n\t\tfor (const item of items) {\n\t\t\tif (excludes.includes(item)) continue\n\t\t\tconst stats = await fs.promises.stat(item)\n\t\t\tif (stats.isDirectory()) {\n\t\t\t\tctx.push(item)\n\t\t\t\tawait recurse(item)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tctx.push(item)\n\t\t}\n\t}\n\n\tawait recurse(entry)\n\treturn ctx\n}\n\nexport async function copyAll(src_dir: string, dst_dir: string, ...excludes: string[]): Promise<void> {\n\tconst dirs: string[] = []\n\tconst srcs: string[] = []\n\n\tconst ctx = await readdirAll(src_dir, ...excludes)\n\tfor (const item of ctx) {\n\t\tconst stats = await fs.promises.stat(item)\n\t\tif (!stats.isDirectory()) {\n\t\t\tsrcs.push(item)\n\t\t} else {\n\t\t\tdirs.push(item)\n\t\t}\n\t}\n\n\tfor (const dir of dirs) await fs.promises.mkdir(path.join(dst_dir, dir.slice(src_dir.length)), { recursive: true })\n\tfor (const src of srcs) await fs.promises.copyFile(src, path.join(dst_dir, src.slice(src_dir.length)))\n}\n", "import * as path from \"path\"\n\n// spaify converts a URL for SPA-mode.\n//\n// TODO: Write tests.\nexport function spaify(_: string): string {\n\treturn \"/\"\n}\n\n// ssgify converts a URL for SSG-mode.\n//\n// TODO: Write tests.\nexport function ssgify(url: string): string {\n\tif (url.endsWith(\"/\")) return url + \"index.html\"\n\tif (path.extname(url) === \"\") return url + \".html\"\n\treturn url\n}\n", "import * as path from \"path\"\n\n// prettier-ignore\nexport interface PathInfo {\n\tsrc: string      // e.g. \"path/to/basename.ext\"\n\tbasename: string // e.g. \"basename.ext\"\n\tname: string     // e.g. \"basename\"\n\text: string      // e.g. \".ext\"\n}\n\nexport function parsePathInfo(src: string): PathInfo {\n\tconst basename = path.basename(src)\n\tconst ext = path.extname(src)\n\tconst name = basename.slice(0, -ext.length)\n\treturn { src, basename, name, ext }\n}\n", "// testURICharacterSafe tests whether a character matches URI reserved or\n// unreserved characters based on RFC 3986.\nfunction testURICharacterSafe(char: string): boolean {\n\t// prettier-ignore\n\tif (\n\t\t(char >= \"a\" && char <= \"z\") || // ALPHA LOWER\n\t\t(char >= \"A\" && char <= \"Z\") || // ALPHA LOWER\n\t\t(char >= \"0\" && char <= \"9\")    // DIGIT\n\t) {\n\t\treturn true\n\t}\n\t// https://tools.ietf.org/html/rfc3986#section-2.3\n\tswitch (char) {\n\t\tcase \"-\":\n\t\tcase \".\":\n\t\tcase \"_\":\n\t\tcase \"~\":\n\t\t\treturn true\n\t}\n\t// https://tools.ietf.org/html/rfc3986#section-2.2\n\tswitch (char) {\n\t\tcase \":\":\n\t\tcase \"/\":\n\t\tcase \"?\":\n\t\tcase \"#\":\n\t\tcase \"[\":\n\t\tcase \"]\":\n\t\tcase \"@\":\n\t\tcase \"!\":\n\t\tcase \"$\":\n\t\tcase \"&\":\n\t\tcase \"'\":\n\t\tcase \"(\":\n\t\tcase \")\":\n\t\tcase \"*\":\n\t\tcase \"+\":\n\t\tcase \",\":\n\t\tcase \";\":\n\t\tcase \"=\":\n\t\t\treturn true\n\t}\n\treturn false\n}\n\nexport function testURISafe(str: string): boolean {\n\tfor (const each of str) {\n\t\tif (!testURICharacterSafe(each)) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n", "export function timestamp(date = new Date()): string {\n\tconst hh = String(date.getHours() % 12 ?? 12).padStart(2, \"0\")\n\tconst mm = String(date.getMinutes()).padStart(2, \"0\")\n\tconst ss = String(date.getSeconds()).padStart(2, \"0\")\n\tconst am = date.getHours() < 12 ? \"AM\" : \"PM\"\n\tconst ms = String(date.getMilliseconds()).slice(0, 3).padStart(3, \"0\")\n\treturn `${hh}:${mm}:${ss}.${ms} ${am}`\n}\n", "import * as fs from \"fs/promises\"\nimport * as p from \"path\"\n\nexport function sleep(ms: number): Promise<void> {\n\treturn new Promise(resolve => setTimeout(resolve, ms))\n}\n\nexport async function* watcher(root: string, { interval }: { interval: number }): AsyncGenerator<string> {\n\tconst mtimeMsMap: { [key: string]: number } = {}\n\n\tasync function read(entry: string, { deep }: { deep: boolean }): Promise<string> {\n\t\tconst stat = await fs.stat(entry)\n\t\tconst mtimeMs = mtimeMsMap[entry]\n\t\tif (mtimeMs === undefined || stat.mtimeMs !== mtimeMs) {\n\t\t\tmtimeMsMap[entry] = stat.mtimeMs\n\t\t\tif (!deep) {\n\t\t\t\treturn entry\n\t\t\t}\n\t\t}\n\t\tif (stat.isDirectory()) {\n\t\t\tfor (const each of await fs.readdir(entry)) {\n\t\t\t\tconst src = p.join(entry, each)\n\t\t\t\tconst result = await read(src, { deep })\n\t\t\t\tif (result !== \"\") {\n\t\t\t\t\tif (!deep) {\n\t\t\t\t\t\treturn result\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"\"\n\t}\n\n\tawait read(root, { deep: true })\n\n\t// Generate source changes:\n\twhile (true) {\n\t\tawait sleep(interval)\n\t\tconst src = await read(root, { deep: false })\n\t\tif (src !== \"\") {\n\t\t\tyield src\n\t\t}\n\t}\n}\n", "import * as log from \"../lib/log\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\n\ninterface CLI {\n\tparseDevCommand(): types.DevCommand\n\tparseExportCommand(): types.ExportCommand\n\tparseServeCommand(): types.ServeCommand\n}\n\n// newCLI creates a new CLI that parses commands.\nexport default function newCLI(...args: string[]): CLI {\n\treturn {\n\t\t// parseDevCommand parses the dev command; 'retro dev ...'.\n\t\tparseDevCommand(): types.DevCommand {\n\t\t\tconst command: types.DevCommand = {\n\t\t\t\ttype: \"dev\",\n\t\t\t\tcached: false,\n\t\t\t\tsourcemap: true,\n\t\t\t\tport: 8000,\n\t\t\t}\n\t\t\tlet badCommand = \"\"\n\t\t\tfor (const arg of args) {\n\t\t\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\t\t\tif (arg === \"--cached\") {\n\t\t\t\t\t\tcommand.cached = true\n\t\t\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\t\t\tcommand.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbadCommand = \"--cached\"\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\t\t\tcommand.sourcemap = true\n\t\t\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\t\t\tcommand.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbadCommand = \"--sourcemap\"\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else if (arg.startsWith(\"--port\")) {\n\t\t\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\t\t\tcommand.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbadCommand = \"--port\"\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbadCommand = arg\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (badCommand !== \"\") {\n\t\t\t\tlog.error(`Bad command ${term.magenta(`'${badCommand}'`)}. Use ${term.magenta(\"'retro help'\")} for help.`)\n\t\t\t}\n\t\t\tif (command.port < 1e3 || command.port >= 1e4) {\n\t\t\t\tlog.error(`${term.magenta(\"'--port'\")} must be between 1000-9999.`)\n\t\t\t}\n\t\t\treturn command\n\t\t},\n\n\t\t// parseExportCommand parses the export command; 'retro export ...'.\n\t\tparseExportCommand(): types.ExportCommand {\n\t\t\tconst command: types.ExportCommand = {\n\t\t\t\ttype: \"export\",\n\t\t\t\tcached: false,\n\t\t\t\tsourcemap: true,\n\t\t\t}\n\t\t\tlet badCommand = \"\"\n\t\t\tfor (const arg of args) {\n\t\t\t\tif (arg.startsWith(\"--cached\")) {\n\t\t\t\t\tif (arg === \"--cached\") {\n\t\t\t\t\t\tcommand.cached = true\n\t\t\t\t\t} else if (arg === \"--cached=true\" || arg === \"--cached=false\") {\n\t\t\t\t\t\tcommand.cached = JSON.parse(arg.slice(\"--cached=\".length))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbadCommand = \"--cached\"\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else if (arg.startsWith(\"--sourcemap\")) {\n\t\t\t\t\tif (arg === \"--sourcemap\") {\n\t\t\t\t\t\tcommand.sourcemap = true\n\t\t\t\t\t} else if (arg === \"--sourcemap=true\" || arg === \"--sourcemap=false\") {\n\t\t\t\t\t\tcommand.sourcemap = JSON.parse(arg.slice(\"--sourcemap=\".length))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbadCommand = \"--sourcemap\"\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbadCommand = arg\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (badCommand !== \"\") {\n\t\t\t\tlog.error(`Bad command ${term.magenta(`'${badCommand}'`)}. Use ${term.magenta(\"'retro help'\")} for help.`)\n\t\t\t}\n\t\t\treturn command\n\t\t},\n\n\t\t// parseServeCommand parses the serve command; 'retro serve ...'.\n\t\tparseServeCommand(): types.ServeCommand {\n\t\t\tconst command: types.ServeCommand = {\n\t\t\t\ttype: \"serve\",\n\t\t\t\tmode: \"ssg\",\n\t\t\t\tport: 8000,\n\t\t\t}\n\t\t\tlet badCommand = \"\"\n\t\t\tfor (const arg of args) {\n\t\t\t\tif (arg.startsWith(\"--mode\")) {\n\t\t\t\t\tif (arg === \"--mode=spa\") {\n\t\t\t\t\t\tcommand.mode = \"spa\"\n\t\t\t\t\t} else if (arg === \"--mode=ssg\") {\n\t\t\t\t\t\tcommand.mode = \"ssg\"\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbadCommand = \"--mode\"\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else if (arg.startsWith(\"--port\")) {\n\t\t\t\t\tif (/^--port=\\d+$/.test(arg)) {\n\t\t\t\t\t\tcommand.port = JSON.parse(arg.slice(\"--port=\".length))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbadCommand = \"--port\"\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbadCommand = arg\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (badCommand !== \"\") {\n\t\t\t\tlog.error(`Bad command ${term.magenta(`'${badCommand}'`)}. Use ${term.magenta(\"'retro help'\")} for help.`)\n\t\t\t}\n\t\t\tif (command.port < 1e3 || command.port >= 1e4) {\n\t\t\t\tlog.error(`${term.magenta(\"'--port'\")} must be between 1000-9999.`)\n\t\t\t}\n\t\t\treturn command\n\t\t},\n\t}\n}\n", "import * as errors from \"./errors\"\nimport * as fs from \"fs\"\nimport * as log from \"../lib/log\"\nimport * as path from \"path\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\nimport parsePageInfosFromDirectories from \"./pages\"\n\nexport default async function newRuntimeFromCommand(command: types.Command): Promise<types.Runtime<typeof command>> {\n\tconst runtime: types.Runtime = {\n\t\tcommand,\n\t\tdirectories: {\n\t\t\tpublicDirectory: \"public\",\n\t\t\tsrcPagesDirectory: \"src/pages\",\n\t\t\tcacheDirectory: \"__cache__\",\n\t\t\texportDirectory: \"__export__\",\n\t\t},\n\t\tdocument: \"\",\n\t\tpages: [],\n\t\trouter: {},\n\n\t\t// guards runs server guards.\n\t\tasync guards(): Promise<void> {\n\t\t\tconst dirs = [\n\t\t\t\truntime.directories.publicDirectory,\n\t\t\t\truntime.directories.srcPagesDirectory,\n\t\t\t\truntime.directories.cacheDirectory,\n\t\t\t\truntime.directories.exportDirectory,\n\t\t\t]\n\n\t\t\tfor (const dir of dirs) {\n\t\t\t\ttry {\n\t\t\t\t\tawait fs.promises.stat(dir)\n\t\t\t\t} catch (err) {\n\t\t\t\t\tfs.promises.mkdir(dir, { recursive: true })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst src = path.join(runtime.directories.publicDirectory, \"index.html\")\n\n\t\t\ttry {\n\t\t\t\tfs.promises.stat(src)\n\t\t\t} catch (err) {\n\t\t\t\tawait fs.promises.writeFile(\n\t\t\t\t\tsrc,\n\t\t\t\t\tutils.detab(`\n\t\t\t\t\t\t<!DOCTYPE html>\n\t\t\t\t\t\t<html lang=\"en\">\n\t\t\t\t\t\t\t<head>\n\t\t\t\t\t\t\t\t<meta charset=\"utf-8\" />\n\t\t\t\t\t\t\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n\t\t\t\t\t\t\t\t%head%\n\t\t\t\t\t\t\t</head>\n\t\t\t\t\t\t\t<body>\n\t\t\t\t\t\t\t\t%page%\n\t\t\t\t\t\t\t</body>\n\t\t\t\t\t\t</html>\n\t\t\t\t\t`),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst buf = await fs.promises.readFile(src)\n\t\t\tconst str = buf.toString()\n\n\t\t\tif (!str.includes(\"%head\")) {\n\t\t\t\tlog.error(errors.missingDocumentHeadTag(src))\n\t\t\t} else if (!str.includes(\"%page\")) {\n\t\t\t\tlog.error(errors.missingDocumentPageTag(src))\n\t\t\t}\n\t\t},\n\n\t\t// resolveDocument resolves and or refreshes this.document.\n\t\tasync resolveDocument(): Promise<void> {\n\t\t\tconst src = path.join(this.directories.publicDirectory, \"index.html\")\n\t\t\tconst buf = await fs.promises.readFile(src)\n\t\t\tconst str = buf.toString()\n\t\t\tthis.document = str\n\t\t},\n\n\t\t// resolvePages resolves and or refreshes this.pages.\n\t\tasync resolvePages(): Promise<void> {\n\t\t\tthis.pages = await parsePageInfosFromDirectories(this.directories)\n\t\t},\n\n\t\t// resolveRouter resolves and or refreshes this.router.\n\t\tasync resolveRouter(): Promise<void> {\n\t\t\t// ...\n\t\t},\n\n\t\t// purgeCacheDirectory purges __cache__.\n\t\tasync purgeCacheDirectory(): Promise<void> {\n\t\t\tawait fs.promises.rmdir(runtime.directories.cacheDirectory, { recursive: true })\n\t\t},\n\n\t\t// purgeExportDirectory purges __export__.\n\t\tasync purgeExportDirectory(): Promise<void> {\n\t\t\tconst dirs = runtime.directories\n\n\t\t\tawait fs.promises.rmdir(dirs.exportDirectory, { recursive: true })\n\t\t\tawait utils.copyAll(\n\t\t\t\tdirs.publicDirectory,\n\t\t\t\tpath.join(dirs.exportDirectory, dirs.publicDirectory),\n\t\t\t\tpath.join(dirs.srcPagesDirectory, \"index.html\"),\n\t\t\t)\n\t\t},\n\t}\n\n\tasync function start(): Promise<void> {\n\t\tif (runtime.command.type === \"export\") {\n\t\t\t// No-op\n\t\t\treturn\n\t\t}\n\t\tawait runtime.guards()\n\t\tawait runtime.resolveDocument()\n\t\tawait runtime.resolvePages()\n\t\tawait runtime.resolveRouter()\n\t}\n\n\tawait start()\n\treturn runtime\n}\n", "import * as errors from \"./errors\"\nimport * as log from \"../lib/log\"\nimport * as path from \"path\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\nconst dynamicPathRegex = /(\\/)(\\[)([a-zA-Z0-9\\-\\.\\_\\~\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]+)(\\])/\n\n// \"src/pages/index.js\" -> \"/\"\n// \"src/pages/page.js\" -> \"/page\"\n// \"src/pages/nested/page.js\" -> \"/nested/page\"\n//\n// TODO: Write tests.\nfunction path_(dirs: types.Directories, pathInfo: utils.PathInfo): string {\n\tconst out = pathInfo.src.slice(dirs.srcPagesDirectory.length, -pathInfo.ext.length)\n\tif (out.endsWith(\"/index\")) {\n\t\treturn out.slice(0, -\"index\".length)\n\t}\n\treturn out\n}\n\n// src/pages/index.js -> __export__/index.html\n// src/pages/page.js -> __export__/page.html\n// src/pages/nested/page.js -> __export__/nested/page.html\n//\n// TODO: Write tests.\nfunction dst(dirs: types.Directories, pathInfo: utils.PathInfo): string {\n\tconst out = path.join(dirs.exportDirectory, pathInfo.src.slice(dirs.srcPagesDirectory.length))\n\treturn out.slice(0, -pathInfo.ext.length) + \".html\"\n}\n\n// src/pages/index.js -> StaticIndex\n// src/pages/page.js -> StaticPage\n// src/pages/nested/page.js -> StaticNestedPage\n//\n// TODO: Write tests.\nfunction component(dirs: types.Directories, pathInfo: utils.PathInfo, { dynamic }: { dynamic: boolean }): string {\n\tlet out = \"\"\n\tconst parts = path_(dirs, pathInfo).split(path.sep)\n\tfor (let part of parts) {\n\t\tif (part.startsWith(\"[\") && part.endsWith(\"]\")) {\n\t\t\tpart = part.slice(1, -1) // Remove \"[\" and \"]\" syntax\n\t\t}\n\t\tif (part.length === 0) continue\n\t\tout += part[0]!.toUpperCase() + part.slice(1)\n\t}\n\tout = (!dynamic ? \"Static\" : \"Dynamic\") + (out ?? \"Index\")\n\treturn out\n}\n\n// TODO: Write tests.\nfunction newPageInfo(dirs: types.Directories, pathInfo: utils.PathInfo): types.StaticPageInfo {\n\tconst out: types.StaticPageInfo = {\n\t\ttype: \"static\",\n\t\tsrc: pathInfo.src,\n\t\tdst: dst(dirs, pathInfo),\n\t\tpath: path_(dirs, pathInfo),\n\t\tcomponent: component(dirs, pathInfo, { dynamic: false }),\n\t}\n\treturn out\n}\n\n// TODO: Write tests.\nfunction newDynamicPageInfo(dirs: types.Directories, pathInfo: utils.PathInfo): types.DynamicPageInfo {\n\tconst out: types.DynamicPageInfo = {\n\t\ttype: \"dynamic\",\n\t\tsrc: pathInfo.src,\n\t\tcomponent: component(dirs, pathInfo, { dynamic: true }),\n\t}\n\treturn out\n}\n\nconst supportedExts: { [key: string]: boolean } = {\n\t\".js\": true,\n\t\".jsx\": true,\n\t\".ts\": true,\n\t\".tsx\": true,\n\t\".md\": true, // TODO\n\t\".mdx\": true, // TODO\n}\n\nexport default async function parsePageInfosFromDirectories(dirs: types.Directories): Promise<types.PageInfo[]> {\n\tconst srcs = await utils.readdirAll(dirs.srcPagesDirectory)\n\n\t// TODO: Add support for <Layout> components.\n\tconst pathInfos = srcs\n\t\t.map(src => utils.parsePathInfo(src))\n\t\t.filter(pathInfo => {\n\t\t\tif (/^(_|$)|($|_)$/.test(pathInfo.name)) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn supportedExts[pathInfo.ext] !== undefined\n\t\t})\n\n\tconst badSrcs: string[] = []\n\tfor (const pathInfo of pathInfos) {\n\t\tif (!utils.testURISafe(pathInfo.src)) {\n\t\t\tbadSrcs.push(pathInfo.src)\n\t\t}\n\t}\n\n\tif (badSrcs.length > 0) {\n\t\tlog.error(errors.pagesUseNonURICharacters(badSrcs))\n\t}\n\n\tconst pages: types.PageInfo[] = []\n\tfor (const pathInfo of pathInfos) {\n\t\tconst syntax = path_(dirs, pathInfo)\n\t\tif (!dynamicPathRegex.test(syntax)) {\n\t\t\tpages.push(newPageInfo(dirs, pathInfo))\n\t\t} else {\n\t\t\tpages.push(newDynamicPageInfo(dirs, pathInfo))\n\t\t}\n\t}\n\treturn pages\n}\n", "import * as esbuild from \"esbuild\"\nimport * as events from \"./events\"\nimport * as fs from \"fs/promises\"\nimport * as http from \"http\"\n// import * as log from \"../lib/log\"\nimport * as p from \"path\"\nimport * as resolvers from \"./router\"\nimport * as resolversText from \"./router-text\"\n// import * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\n// interface ExportCache {\n// \t[key: string]: {\n// \t\tmtimeMs: number\n// \t\thtml: string\n// \t}\n// }\n\n// async function build(runtime: types.Runtime<types.DevCommand>): Promise<esbuild.BuildResult> {\n// \tconst appContents = await resolversText.renderRouterToString(runtime)\n// \tconst appContentsPath = p.join(runtime.directories.cacheDir, \"app.js\")\n// \tawait fs.writeFile(appContentsPath, appContents)\n//\n// \tlet result: esbuild.BuildResult\n// \ttry {\n// \t\tresult = await esbuild.build({\n// \t\t\tincremental: true, // TODO\n//\n// \t\t\tbundle: true,\n// \t\t\tdefine: {\n// \t\t\t\t__DEV__: process.env.__DEV__!,\n// \t\t\t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV),\n// \t\t\t},\n// \t\t\tentryPoints: [appContentsPath],\n// \t\t\tinject: [\"packages/retro/react-shim.js\"],\n// \t\t\tloader: { \".js\": \"jsx\" },\n// \t\t\tlogLevel: \"silent\", // TODO\n// \t\t\tminify: false,\n// \t\t\toutfile: p.join(runtime.directories.exportDirectory, appContentsPath.slice(runtime.directories.srcPagesDir.length)),\n// \t\t\t// plugins: [...configs.retro.plugins], // TODO\n// \t\t})\n// \t\t// TODO: Add support for hints.\n// \t\tif (result.warnings.length > 0) {\n// \t\t\tfor (const warning of result.warnings) {\n// \t\t\t\tlog.warning(utils.formatEsbuildMessage(warning, term.yellow))\n// \t\t\t}\n// \t\t\tprocess.exit(1)\n// \t\t}\n// \t} catch (err) {\n// \t\t// TODO: Differentiate esbuild errors.\n// \t\tlog.error(utils.formatEsbuildMessage((err as esbuild.BuildFailure).errors[0]!, term.bold.red))\n// \t}\n//\n// \treturn result!\n// }\n\n// const cache: ExportCache = {}\n\nexport default async function runDev(runtime: types.Runtime<types.DevCommand>): Promise<void> {\n\t// let emit: () => void | undefined\n\t//\tconst result = await build(runtime)\n\t//\t// TODO: Add esbuild error-handling here.\n\t//\n\t//\tasync function watch(): Promise<void> {\n\t//\t\tconst generator = utils.watcher(\"src\", { interval: 100 })\n\t//\t\tasync function next(): Promise<string> {\n\t//\t\t\treturn (await generator.next()).value\n\t//\t\t}\n\t//\n\t//\t\t// TODO: Add event here.\n\t//\t\twhile (true) {\n\t//\t\t\tawait next()\n\t//\t\t\tawait result.rebuild!()\n\t//\t\t\t// TODO: Add esbuild error-handling here.\n\t//\t\t\tif (emit) emit()\n\t//\t\t}\n\t//\t}\n\t//\n\t//\twatch()\n\n\t// prettier-ignore\n\tconst result = await esbuild.serve({\n\t\tservedir: runtime.directories.exportDirectory,\n\t\tonRequest: (args: esbuild.ServeOnRequestArgs) => events.serve(args)\n\t}, {})\n\n\tconst srvProxy = http.createServer(\n\t\tasync (req: http.IncomingMessage, res: http.ServerResponse): Promise<void> => {\n\t\t\t// Handle /~dev:\n\t\t\tif (req.url === \"/~dev\") {\n\t\t\t\tres.writeHead(200, {\n\t\t\t\t\t\"Content-Type\": \"text/event-stream\",\n\t\t\t\t\t\"Cache-Control\": \"no-cache\",\n\t\t\t\t\tConnection: \"keep-alive\",\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Compute the path from the URL:\n\t\t\tlet path = req.url\n\t\t\tif (p.extname(req.url!) === \".html\") {\n\t\t\t\tpath = path.slice(0, -5)\n\t\t\t}\n\n\t\t\tconst meta = runtime.router[path]\n\t\t\tif (meta !== undefined) {\n\t\t\t\t// Regenerate component.esbuild.js:\n\t\t\t\tconst mod = await resolvers.resolveModule(runtime, { ...meta.route })\n\t\t\t\tconst loaded: types.LoadedRouteMeta = { mod, meta }\n\n\t\t\t\t// Write to disk:\n\t\t\t\tconst out = await resolversText.renderRouteMetaToString(runtime, loaded)\n\t\t\t\tawait fs.mkdir(p.dirname(loaded.meta.route.dst), { recursive: true })\n\t\t\t\tawait fs.writeFile(loaded.meta.route.dst, out)\n\t\t\t}\n\n\t\t\t// Defer to esbuild:\n\t\t\tconst options = {\n\t\t\t\thostname: result.host,\n\t\t\t\tport: result.port,\n\t\t\t\tpath: utils.ssgify(req.url!),\n\t\t\t\tmethod: req.method,\n\t\t\t\theaders: req.headers,\n\t\t\t}\n\n\t\t\tconst reqProxy = http.request(options, (resProxy: http.IncomingMessage): void => {\n\t\t\t\t// Handle 404:\n\t\t\t\tif (resProxy.statusCode === 404) {\n\t\t\t\t\tres.writeHead(404, { \"Content-Type\": \"text/plain\" })\n\t\t\t\t\tres.end(\"404 - Not Found\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// Handle 200:\n\t\t\t\tres.writeHead(resProxy.statusCode!, resProxy.headers)\n\t\t\t\tresProxy.pipe(res, { end: true })\n\t\t\t})\n\t\t\treq.pipe(reqProxy, { end: true })\n\t\t},\n\t)\n\n\tsrvProxy.listen(runtime.command.port)\n}\n\n// // Read from the cache:\n// const stat = await fs.stat(req.url!)\n// const read = cache[req.url!]\n// if (read !== undefined && read.mtimeMs !== stat.mtimeMs) {\n// \tres.writeHead(200, { \"Content-Type\": \"text/html\" })\n// \tres.end(read.html)\n// \treturn\n// }\n\n// // Bad cache read; rerender and cache:\n// const html = await renderToString() // TODO\n// cache[req.url!] = {\n// \tmtimeMs: stat.mtimeMs,\n// \thtml,\n// }\n// // TODO: Emit a log event here (incl. read from the cache or not).\n// res.writeHead(200, { \"Content-Type\": \"text/html\" })\n// res.end(html)\n", "import * as esbuild from \"esbuild\"\nimport * as p from \"path\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\nconst TERM_WIDTH = 40\n\nconst formatter = utils.newFormatter()\n\nfunction formatMS(ms: number): string {\n\tswitch (true) {\n\t\tcase ms < 250:\n\t\t\t// 250ms\n\t\t\treturn `${ms}ms`\n\t\tdefault:\n\t\t\t// 0.25ms\n\t\t\treturn `${(ms / 1e3).toFixed(2)}s`\n\t}\n}\n\nexport function export_(runtime: types.Runtime, meta: types.RouteMeta, start: number): void {\n\tconst dur = formatMS(Date.now() - start)\n\n\tconst l1 = runtime.directories.srcPagesDirectory.length\n\tconst l2 = runtime.directories.exportDirectory.length\n\n\tlet color = term.white\n\tif (meta.route.type === \"dynamic\") {\n\t\tcolor = term.cyan\n\t}\n\n\tlet dimColor = term.dim.white\n\tif (meta.route.type === \"dynamic\") {\n\t\tdimColor = term.dim.cyan\n\t}\n\n\tconst src = meta.route.src.slice(l1)\n\tconst src_ext = p.extname(src)\n\tconst src_name = src.slice(1, -src_ext.length)\n\n\tconst dst = meta.route.dst.slice(l2)\n\tconst dst_ext = p.extname(dst)\n\tconst dst_name = dst.slice(1, -dst_ext.length)\n\n\tconst sep = \"-\".repeat(Math.max(0, TERM_WIDTH - `/${src_name}${src_ext}\\x20`.length))\n\n\tformatter.format()\n\tconsole.log(\n\t\t`\\x20${term.dim(utils.timestamp())}\\x20\\x20` +\n\t\t\t`${dimColor(\"/\")}${color(src_name)}${dimColor(src_ext)} ${dimColor(sep)} ${dimColor(\"/\")}${color(dst_name)}${\n\t\t\t\tstart === 0 ? \"\" : ` ${dimColor(`(${dur})`)}`\n\t\t\t}`,\n\t)\n}\n\nexport function serve(args: esbuild.ServeOnRequestArgs): void {\n\tconst dur = formatMS(args.timeInMS)\n\n\tlet color = term.normal\n\tif (args.status < 200 || args.status >= 300) {\n\t\tcolor = term.red\n\t}\n\n\tlet dimColor = term.dim\n\tif (args.status < 200 || args.status >= 300) {\n\t\tdimColor = term.dim.red\n\t}\n\n\tlet logger = (...args: unknown[]): void => console.log(...args)\n\tif (args.status < 200 || args.status >= 300) {\n\t\tlogger = (...args) => console.error(...args) // eslint-disable-line\n\t}\n\n\tconst path = args.path\n\tconst path_ext = p.extname(path)\n\tconst path_name = path.slice(1, -path_ext.length)\n\n\tconst sep = \"-\".repeat(Math.max(0, TERM_WIDTH - `/${path_name}${path_ext}\\x20`.length))\n\n\tformatter.format()\n\tlogger(\n\t\t`\\x20${term.dim(utils.timestamp())}\\x20\\x20` +\n\t\t\t`${dimColor(\"/\")}${color(path_name)}${dimColor(path_ext)} ${dimColor(sep)} ${color(args.status)} ${dimColor(\n\t\t\t\t`(${dur})`,\n\t\t\t)}`,\n\t)\n}\n", "import * as errors from \"./errors\"\nimport * as esbuild from \"esbuild\"\nimport * as events from \"./events\"\nimport * as fs from \"fs/promises\"\nimport * as log from \"../lib/log\"\nimport * as p from \"path\"\nimport * as resolversText from \"./router-text\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\nconst format = utils.newFormatter()\n\nlet service: esbuild.Service\n\nexport async function resolveModule(\n\truntime: types.Runtime<types.DevCommand | types.ExportCommand>,\n\tpage: types.PageInfo,\n): Promise<types.PageModule> {\n\tconst target = p.join(runtime.directories.cacheDirectory, page.src.replace(/\\.*$/, \".esbuild.js\"))\n\n\t// Cache components to an intermediary build artifact; component.esbuild.js.\n\t// These artifacts enable interop with Node.js because require doesn\u2019t\n\t// understand a) JSX and b) TypeScript.\n\t//\n\t// Previously, there was a prototype that used 'ts-node -T' that was simpler\n\t// but slower.\n\ttry {\n\t\t// Use 'external: [\"react\", \"react-dom\"]' to prevent a runtime React error:\n\t\t// You might have mismatching versions of React and the renderer (such as\n\t\t// React DOM).\n\t\tconst result = await service.build({\n\t\t\tbundle: true,\n\t\t\tdefine: {\n\t\t\t\t__DEV__: process.env.__DEV__!,\n\t\t\t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV!),\n\t\t\t},\n\t\t\tentryPoints: [page.src],\n\t\t\texternal: [\"react\", \"react-dom\"],\n\t\t\tformat: \"cjs\", // Use \"cjs\" to enable require(...)\n\t\t\tinject: [\"packages/retro/react-shim.js\"],\n\t\t\tloader: { \".js\": \"jsx\" },\n\t\t\tlogLevel: \"silent\", // TODO\n\t\t\toutfile: target,\n\t\t\t// plugins: [...configs.retro.plugins], // TODO\n\t\t})\n\t\tif (result.warnings.length > 0) {\n\t\t\tfor (const warning of result.warnings) {\n\t\t\t\tlog.warning(utils.formatEsbuildMessage(warning, term.yellow))\n\t\t\t}\n\t\t\tprocess.exit(1)\n\t\t}\n\t} catch (err) {\n\t\t// TODO: Differentiate esbuild errors.\n\t\tlog.error(utils.formatEsbuildMessage((err as esbuild.BuildFailure).errors[0]!, term.bold.red))\n\t}\n\n\tlet mod: types.PageModule = {}\n\n\t// Use try-catch to suppress esbuild dynamic import warning.\n\t// prettier-ignore\n\ttry { mod = require(p.join(\"..\", \"..\", target)) } catch {}\n\treturn mod\n}\n\nexport async function resolveStaticRoute(\n\truntime: types.Runtime<types.DevCommand | types.ExportCommand>,\n\tpage: types.StaticPageInfo,\n): Promise<types.LoadedRouteMeta> {\n\tlet props: types.RouteProps = { path: page.path }\n\n\t// Guard serverProps and serverPaths:\n\tconst mod = (await resolveModule(runtime, page)) as types.StaticPageModule\n\tif (\"serverProps\" in mod && typeof mod.serverProps !== \"function\") {\n\t\tlog.error(errors.serverPropsFunction(page.src))\n\t} else if (\"serverPaths\" in mod && typeof (mod as { [key: string]: unknown }).serverPaths === \"function\") {\n\t\tlog.error(errors.serverPathsMismatch(page.src))\n\t}\n\n\t// Resolve serverProps:\n\tif (typeof mod.serverProps === \"function\") {\n\t\ttry {\n\t\t\tconst serverProps = await mod.serverProps!()\n\t\t\tif (!utils.validateServerPropsReturn(serverProps)) {\n\t\t\t\tlog.error(errors.serverPropsReturn(page.src))\n\t\t\t}\n\t\t\tprops = {\n\t\t\t\t// @ts-ignore\n\t\t\t\tpath: page.path, // Add path (takes precedence)\n\t\t\t\t...serverProps,\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlog.error(`${page.src}.serverProps: ${err.message}`)\n\t\t}\n\t}\n\n\tconst loaded = { mod, meta: { route: page, props } }\n\treturn loaded\n}\n\nexport async function resolveDynamicRoutes(\n\truntime: types.Runtime<types.DevCommand | types.ExportCommand>,\n\tpage: types.DynamicPageInfo,\n): Promise<types.LoadedRouteMeta[]> {\n\tconst loaded: types.LoadedRouteMeta[] = []\n\n\t// Guard serverProps and serverPaths:\n\tconst mod = (await resolveModule(runtime, page)) as types.DynamicPageModule\n\tif (\"serverPaths\" in mod && typeof mod.serverPaths !== \"function\") {\n\t\tlog.error(errors.serverPathsFunction(page.src))\n\t} else if (\"serverProps\" in mod && typeof (mod as { [key: string]: unknown }).serverProps === \"function\") {\n\t\tlog.error(errors.serverPropsMismatch(page.src))\n\t}\n\n\t// Resolve serverPaths:\n\tif (typeof mod.serverPaths === \"function\") {\n\t\tlet paths: { path: string; props: types.Props }[] = []\n\t\ttry {\n\t\t\tpaths = await mod.serverPaths!()\n\t\t\tif (!utils.validateServerPathsReturn(paths)) {\n\t\t\t\tlog.error(errors.serverPathsReturn(page.src))\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tlog.error(`${page.src}.serverPaths: ${err.message}`)\n\t\t}\n\n\t\tfor (const path of paths) {\n\t\t\tconst path_ = p.join(p.dirname(page.src).slice(runtime.directories.srcPagesDirectory.length), path.path)\n\t\t\tconst dst = p.join(runtime.directories.exportDirectory, path_ + \".html\")\n\t\t\tloaded.push({\n\t\t\t\tmod,\n\t\t\t\tmeta: {\n\t\t\t\t\t// prettier-ignore\n\t\t\t\t\troute: {\n\t\t\t\t\t\t...page,\n\t\t\t\t\t\tdst,         // Add dst\n\t\t\t\t\t\tpath: path_, // Add path\n\t\t\t\t\t},\n\t\t\t\t\tprops: {\n\t\t\t\t\t\tpath: path_, // Add path (takes precedence)\n\t\t\t\t\t\t...path.props,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t})\n\t\t}\n\t}\n\n\treturn loaded\n}\n\n// resolveRouter resolves serverProps and serverPaths and generates the server-\n// resolved router.\n//\n// TODO: Extract middleware so loggers can be externalized?\nexport async function resolveRouter(\n\truntime: types.Runtime<types.DevCommand | types.ExportCommand>,\n): Promise<types.Router> {\n\tconst router: types.Router = {}\n\n\t// TODO: Add --concurrent?\n\tservice = await esbuild.startService()\n\tfor (const page of runtime.pages) {\n\t\tlet start = Date.now()\n\n\t\tconst loaded: types.LoadedRouteMeta[] = []\n\t\tif (page.type === \"static\") {\n\t\t\tconst one = await resolveStaticRoute(runtime, page)\n\t\t\tloaded.push(one)\n\t\t} else {\n\t\t\tconst many = await resolveDynamicRoutes(runtime, page)\n\t\t\tloaded.push(...many)\n\t\t}\n\n\t\tfor (const each of loaded) {\n\t\t\tif (router[each.meta.route.path] !== undefined) {\n\t\t\t\tlog.error(errors.duplicatePathFound(each.meta.route, router[each.meta.route.path]!.route))\n\t\t\t}\n\t\t\tformat.format()\n\t\t\trouter[each.meta.route.path] = each.meta\n\n\t\t\t// Write to disk:\n\t\t\tif (runtime.command.type === \"export\") {\n\t\t\t\tconst out = await resolversText.renderRouteMetaToString(runtime, each)\n\t\t\t\tawait fs.mkdir(p.dirname(each.meta.route.dst), { recursive: true })\n\t\t\t\tawait fs.writeFile(each.meta.route.dst, out)\n\t\t\t}\n\n\t\t\tevents.export_(runtime, each.meta, start)\n\t\t\tstart = 0 // Reset\n\t\t}\n\t}\n\n\tformat.done()\n\treturn router\n}\n", "import * as log from \"../lib/log\"\nimport * as React from \"react\"\nimport * as ReactDOMServer from \"react-dom/server\"\nimport * as types from \"./types\"\n\n// TODO: Add support for <Layout> components.\n// TODO: Write tests.\nexport async function renderRouteMetaToString(runtime: types.Runtime, loaded: types.LoadedRouteMeta): Promise<string> {\n\tlet head = \"<!-- <Head> -->\"\n\ttry {\n\t\tif (typeof loaded.mod.Head === \"function\") {\n\t\t\tconst renderString = ReactDOMServer.renderToStaticMarkup(React.createElement(loaded.mod.Head, loaded.meta.props))\n\t\t\thead = renderString.replace(/></g, \">\\n\\t\\t<\").replace(/\\/>/g, \" />\")\n\t\t}\n\t} catch (err) {\n\t\tlog.error(`${loaded.meta.route.src}.<Head>: ${err.message}`)\n\t}\n\n\t// TODO: Upgrade <script src=\"/app.js\"> to <script src=\"/app.[hash].js\">?\n\tlet page = `<noscript>You need to enable JavaScript to run this app.</noscript>\\n\\t\\t<div id=\"root\"></div>\\n\\t\\t<script src=\"/app.js\"></script>`\n\ttry {\n\t\tif (typeof loaded.mod.default === \"function\") {\n\t\t\tconst renderString = ReactDOMServer.renderToString(React.createElement(loaded.mod.default, loaded.meta.props))\n\t\t\tpage = page.replace(`<div id=\"root\"></div>`, `<div id=\"root\">${renderString}</div>`)\n\t\t}\n\t} catch (err) {\n\t\tlog.error(`${loaded.meta.route.src}.<Page>: ${err.message}`)\n\t}\n\n\tconst out = runtime.document\n\t\t.replace(\"%head%\", head) // %head% -> <Head>\n\t\t.replace(\"%page%\", page) // %page% -> <Page>\n\treturn out\n}\n\n// TODO: Add support for <Layout> components.\n// TODO: Write tests.\nexport async function renderRouterToString(runtime: types.Runtime): Promise<string> {\n\tconst distinctComponents = [...new Set(runtime.pages.map(each => each.component))] // TODO: Change to router?\n\n\tconst distinctRoutes = runtime.pages\n\t\t.filter(route => distinctComponents.includes(route.component))\n\t\t.sort((a, b) => a.component.localeCompare(b.component))\n\n\treturn `import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport { Route, Router } from \"../packages/router\"\n\n// Components\n${distinctRoutes.map(route => `import ${route.component} from \"../${route.src}\"`).join(\"\\n\")}\n\nexport default function App() {\n\treturn (\n\t\t<Router>\n${\n\tObject.entries(runtime.router)\n\t\t.map(\n\t\t\t([path, meta]) => `\n\t\t\t<Route path=\"${path}\">\n\t\t\t\t<${meta.route.component} {...${JSON.stringify(meta.props)}} />\n\t\t\t</Route>`,\n\t\t)\n\t\t.join(\"\\n\") + \"\\n\"\n}\n\t\t</Router>\n\t)\n}\n\n${\n\tJSON.parse(process.env.STRICT_MODE ?? \"true\") === \"true\"\n\t\t? `ReactDOM.${JSON.parse(process.env.RENDER ?? \"false\") === \"true\" ? \"render\" : \"hydrate\"}(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById(\"root\"),\n)`\n\t\t: `ReactDOM.${JSON.parse(process.env.RENDER ?? \"false\") === \"true\" ? \"render\" : \"hydrate\"}(\n\t<App />,\n\tdocument.getElementById(\"root\"),\n)`\n}\n` // EOF\n}\n", "// import * as esbuild from \"esbuild\"\n// import * as fs from \"fs/promises\"\n// import * as log from \"../lib/log\"\n// import * as p from \"path\"\n// import * as term from \"../lib/term\"\n// import * as textResolvers from \"./router-text\"\nimport * as types from \"./types\"\n// import * as utils from \"./utils\"\n\nexport default async function runExport(runtime: types.Runtime<types.ExportCommand>): Promise<void> {\n\tconsole.log(runtime.router)\n\n\t//\tconst appContents = await textResolvers.renderRouterToString(runtime)\n\t//\tconst appContentsPath = p.join(runtime.directories.cacheDirectory, \"app.js\")\n\t//\tawait fs.writeFile(appContentsPath, appContents)\n\t//\n\t//\ttry {\n\t//\t\tconst result = await esbuild.build({\n\t//\t\t\tbundle: true,\n\t//\t\t\tdefine: {\n\t//\t\t\t\t__DEV__: process.env.__DEV__!,\n\t//\t\t\t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV),\n\t//\t\t\t},\n\t//\t\t\tentryPoints: [appContentsPath],\n\t//\t\t\tinject: [\"packages/retro/react-shim.js\"],\n\t//\t\t\tloader: { \".js\": \"jsx\" },\n\t//\t\t\tlogLevel: \"silent\", // TODO\n\t//\t\t\tminify: true,\n\t//\t\t\toutfile: p.join(\n\t//\t\t\t\truntime.directories.exportDirectory,\n\t//\t\t\t\tappContentsPath.slice(runtime.directories.srcPagesDirectory.length),\n\t//\t\t\t),\n\t//\t\t\t// plugins: [...configs.retro.plugins], // TODO\n\t//\t\t})\n\t//\t\t// TODO: Add support for hints.\n\t//\t\tif (result.warnings.length > 0) {\n\t//\t\t\tfor (const warning of result.warnings) {\n\t//\t\t\t\tlog.warning(utils.formatEsbuildMessage(warning, term.yellow))\n\t//\t\t\t}\n\t//\t\t\tprocess.exit(1)\n\t//\t\t}\n\t//\t} catch (err) {\n\t//\t\t// TODO: Differentiate esbuild errors.\n\t//\t\tlog.error(utils.formatEsbuildMessage((err as esbuild.BuildFailure).errors[0]!, term.bold.red))\n\t//\t}\n}\n", "import * as errors from \"./errors\"\nimport * as esbuild from \"esbuild\"\nimport * as events from \"./events\"\nimport * as fs from \"fs/promises\"\nimport * as http from \"http\"\nimport * as log from \"../lib/log\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\n// This implementation is roughly based on:\n//\n// - https://esbuild.github.io/api/#customizing-server-behavior\n// - https://github.com/evanw/esbuild/issues/858#issuecomment-782814216\n//\nexport default async function runServe(runtime: types.Runtime<types.ServeCommand>): Promise<void> {\n\ttry {\n\t\tawait fs.stat(runtime.directories.exportDirectory)\n\t} catch {\n\t\tlog.error(errors.serveWithMissingExportDirectory)\n\t}\n\n\t// prettier-ignore\n\tconst result = await esbuild.serve({\n\t\tservedir: runtime.directories.exportDirectory,\n\t\tonRequest: (args: esbuild.ServeOnRequestArgs) => events.serve(args),\n\t}, {})\n\n\tconst serverProxy = http.createServer((req: http.IncomingMessage, res: http.ServerResponse): void => {\n\t\tconst opts = {\n\t\t\thostname: result.host,\n\t\t\tport: result.port,\n\t\t\tpath: utils.ssgify(req.url!),\n\t\t\tmethod: req.method,\n\t\t\theaders: req.headers,\n\t\t}\n\t\tconst requestProxy = http.request(opts, (responseProxy: http.IncomingMessage): void => {\n\t\t\t// Handle 404:\n\t\t\tif (responseProxy.statusCode === 404) {\n\t\t\t\tres.writeHead(404, { \"Content-Type\": \"text/plain\" })\n\t\t\t\tres.end(\"404 - Not Found\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Handle 200:\n\t\t\tres.writeHead(responseProxy.statusCode!, responseProxy.headers)\n\t\t\tresponseProxy.pipe(res, { end: true })\n\t\t})\n\t\treq.pipe(requestProxy, { end: true })\n\t})\n\n\tserverProxy.listen(runtime.command.port)\n}\n", "import * as errors from \"./errors\"\nimport * as log from \"../lib/log\"\nimport * as term from \"../lib/term\"\nimport * as types from \"./types\"\nimport * as utils from \"./utils\"\n\nimport newCLI from \"./cli\"\nimport newRuntimeFromCommand from \"./runtime\"\nimport runDev from \"./run-dev\"\nimport runExport from \"./run-export\"\nimport runServe from \"./run-serve\"\n\n// space converts tabs to one space; \"\\x20\".\nfunction space(str: string): string {\n\treturn str\n\t\t.split(\"\\n\")\n\t\t.map(each => {\n\t\t\tif (each.length === 0) return\n\t\t\treturn each.replace(\"\\t\", \"\\x20\") // \"\\t\" -> \"\\x20\"\n\t\t})\n\t\t.join(\"\\n\")\n}\n\nconst usage = space(`\n\t${term.bold(\"Usage:\")}\n\n\t\tretro dev          Start the dev server\n\t\tretro export       Export the production-ready build (SSG)\n\t\tretro serve        Serve the production-ready build\n\n\t${term.bold(\"retro dev\")}\n\n\t\tStart the dev server\n\n\t\t\t--cached=...     Use cached resources (default false)\n\t\t\t--sourcemap=...  Add source maps (default true)\n\t\t\t--mode=...       Serve mode 'spa' or 'ssg' (default 'ssg') (experimental)\n\t\t\t--port=...       Port number (default 8000)\n\n\t${term.bold(\"retro export\")}\n\n\t\tExport the production-ready build (SSG)\n\n\t\t\t--cached=...     Use cached resources (default false)\n\t\t\t--sourcemap=...  Add source maps (default true)\n\n\t${term.bold(\"retro serve\")}\n\n\t\tServe the production-ready build\n\n\t\t\t--mode=...       Serve mode 'spa' or 'ssg' (default 'ssg') (experimental)\n\t\t\t--port=...       Port number (default 8000)\n\n\t${term.bold(\"Repository\")}\n\n\t\t${term.bold.underline.cyan(\"https://github.com/zaydek/retro\")}\n`)\n\nasync function main(): Promise<void> {\n\tconst argv = process.argv\n\tif (process.argv0 === \"node\") {\n\t\targv.shift()\n\t}\n\n\tlet runCommand = \"usage\"\n\tif (argv.length >= 2) {\n\t\trunCommand = argv[1]!\n\t}\n\n\tlet command: types.Command\n\n\tconst cli = newCLI(...argv.slice(2))\n\tswitch (runCommand) {\n\t\t// Version:\n\t\tcase \"version\":\n\t\tcase \"--version\":\n\t\tcase \"--v\":\n\t\t\tconsole.log(process.env[\"RETRO_VERSION\"] ?? \"TODO\")\n\t\t\tprocess.exit(0)\n\t\tcase \"usage\":\n\t\tcase \"--usage\":\n\t\t\tconsole.log(usage)\n\t\t\tprocess.exit(0)\n\t\tcase \"help\":\n\t\tcase \"--help\":\n\t\t\tconsole.log(usage)\n\t\t\tprocess.exit(0)\n\t\tcase \"dev\":\n\t\t\tutils.setEnvDevelopment()\n\t\t\tcommand = cli.parseDevCommand()\n\t\t\tbreak\n\t\tcase \"export\":\n\t\t\tutils.setEnvProduction()\n\t\t\tcommand = cli.parseExportCommand()\n\t\t\tbreak\n\t\tcase \"serve\":\n\t\t\tutils.setEnvProduction()\n\t\t\tcommand = cli.parseServeCommand()\n\t\t\tbreak\n\t\tdefault:\n\t\t\tlog.error(errors.badCLIRunCommand(runCommand))\n\t\t\tbreak\n\t}\n\n\tconst runtime = await newRuntimeFromCommand(command!)\n\n\tconst run = runtime.command.type\n\tswitch (run) {\n\t\tcase \"dev\":\n\t\t\tawait runDev(runtime as types.Runtime<types.DevCommand>)\n\t\t\tbreak\n\t\tcase \"export\":\n\t\t\tawait runExport(runtime as types.Runtime<types.ExportCommand>)\n\t\t\tbreak\n\t\tcase \"serve\":\n\t\t\tawait runServe(runtime as types.Runtime<types.ServeCommand>)\n\t\t\tbreak\n\t}\n}\n\nprocess.on(\"uncaughtException\", (err: Error): void => {\n\tprocess.env[\"STACK_TRACE\"] = \"true\"\n\terr.message = `UncaughtException: ${err.message}`\n\tlog.error(err)\n})\n\nmain()\n"],
  "mappings": "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",
  "names": []
}
